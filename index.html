    <!-- 

⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⣦⣶⣾⣿⣷⣶⣶⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣶⣿⣟⠯⠓⣉⣩⣭⣝⣻⣿⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⠗⢡⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⠏⣰⣿⣿⣿⣿⣿⣿⣿⠋⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⣿⣿⣿⢠⣿⣿⣿⣿⣿⠿⢿⣿⣀⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣸⣿⣿⣿⠋⠀⠀⠀⣨⣩⠙⠀⢹⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠻⣿⣿⣿⣿⡏⣀⣀⣀⣀⢧⣿⠂⣀⠀⣿⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣶⣿⣿⠗⡤⢤⣀⡉⠊⡱⢋⣉⣉⣷⠄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⡝⣿⣿⠀⠈⠙⠿⠃⠀⡇⠽⠛⢻⡏⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⣿⣿⣿⣿⣿⡀⠀⣀⠤⠾⣄⡹⣄⠀⢸⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣋⢹⣿⣿⣷⡾⢄⠀⠀⠀⠀⢈⣶⣿⠿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣇⣸⣿⣿⣿⣿⣿⡏⢻⣿⣿⣇⠈⠡⢄⣀⠐⢉⣿⣿⣴⣿⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⡿⠟⢻⣿⣿⣿⠀⠀⠻⣿⣿⣷⣤⣄⣠⣴⣿⣿⣿⣿⣿⣿⣇⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⣠⠔⠒⠒⠉⠀⠀⠀⣿⣿⣿⡇⠀⠀⠀⠉⠛⢿⣿⡿⠛⠋⠘⣿⣿⠿⢯⠛⠂⠤⢄⡀⠀⠀⠀⠀
⠀⣠⠊⠁⠀⠀⠀⠀⠀⠀⠀⢻⠁⠀⠸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠀⠀⠀⠀⠀⡇⠀
⣰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢇⠀⠀⢣⠒⠲⠤⣀⡀⠀⡀⣀⠤⠒⠂⠸⡀⠀⢱⠀⠀⠀⠀⠀⠀⠙⣄
⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢆⡀⠀⢣⡀⠀⠈⠀⠈⠀⠃⠀⠀⠀⠰⠧⠀⠚⠀⠀⠀⠀⠀⠀⠀⠙
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀jai Shree Ram 
                        💓💓⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
Vats Mera Source Code Chori Mat Karo , Khud ki website Banao!!! Samjhe ...
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <title>BitBlitz Games - Play Fun Games Online</title>
    <style>
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', "Poppins", Geneva, Verdana, sans-serif;
    background: linear-gradient(-45deg, #667eea, #764ba2, #f093fb, #f5576c);
    background-size: 400% 400%;
    animation: gradientBG 15s ease infinite;
    min-height: 100vh;
    color: white;
    overflow-x: hidden;
}

@keyframes gradientBG {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* Floating particles background */
.particles {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: -1;
}

.particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 50%;
    animation: float 6s ease-in-out infinite;
}

@keyframes float {
    0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 1; }
    50% { transform: translateY(-20px) rotate(180deg); opacity: 0.5; }
}

.header {
    background: rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(20px);
    padding: 1rem 2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    position: sticky;
    top: 0;
    z-index: 100;
}

.logo {
    font-size: 2.5rem;
    font-weight: bold;
    background: linear-gradient(45deg, #ff6b6b, #ffd93d, #4ecdc4);
    background-size: 200% 200%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
    animation: logoGlow 3s ease-in-out infinite alternate;
    cursor: pointer;
    transition: transform 0.3s ease;
}

.logo:hover {
    transform: scale(1.05) rotate(2deg);
}

@keyframes logoGlow {
    from { filter: drop-shadow(0 0 10px rgba(255, 107, 107, 0.3)); }
    to { filter: drop-shadow(0 0 20px rgba(255, 217, 61, 0.6)); }
}

.nav-buttons {
    display: flex;
    gap: 1rem;
}

.nav-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: 30px;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    backdrop-filter: blur(10px);
    font-weight: 600;
    position: relative;
    overflow: hidden;
}

.nav-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.5s ease;
}

.nav-btn:hover::before {
    left: 100%;
}

.nav-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 2rem;
    position: relative;
}

.game-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 2.5rem;
    margin-top: 3rem;
}

.game-card {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(15px);
    border-radius: 25px;
    padding: 2rem;
    border: 2px solid rgba(255, 255, 255, 0.1);
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transform-style: preserve-3d;
}

.game-card::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: conic-gradient(transparent, rgba(255, 255, 255, 0.1), transparent);
    transform: rotate(0deg);
    transition: all 0.6s ease;
    opacity: 0;
    z-index: -1;
}

.game-card:hover::before {
    opacity: 1;
    transform: rotate(360deg);
    animation: rotate 2s linear infinite;
}

@keyframes rotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.game-card:hover {
    transform: translateY(-10px) rotateX(5deg) rotateY(5deg);
    background: rgba(255, 255, 255, 0.15);
    box-shadow: 
        0 25px 50px rgba(0, 0, 0, 0.3),
        0 0 50px rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.3);
}

.game-icon {
    font-size: 4rem;
    margin-bottom: 1rem;
    display: block;
    text-align: center;
    filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.3));
    animation: bounce 2s ease-in-out infinite;
}

@keyframes bounce {
    0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
    40% { transform: translateY(-10px); }
    60% { transform: translateY(-5px); }
}

.game-title {
    font-size: 1.8rem;
    font-weight: bold;
    margin-bottom: 1rem;
    color: #ffd93d;
    text-align: center;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.game-description {
    font-size: 1rem;
    opacity: 0.9;
    margin-bottom: 1.5rem;
    line-height: 1.6;
    text-align: center;
    color: rgba(255, 255, 255, 0.8);
}

.play-btn {
    background: linear-gradient(45deg, #ff6b6b, #ff8e53, #ff6b6b);
    background-size: 200% 200%;
    border: none;
    color: white;
    padding: 1rem 2rem;
    border-radius: 30px;
    cursor: pointer;
    font-weight: bold;
    font-size: 1.1rem;
    transition: all 0.4s ease;
    width: 100%;
    position: relative;
    overflow: hidden;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.play-btn::before {
    content: '🎮';
    position: absolute;
    left: -30px;
    top: 50%;
    transform: translateY(-50%);
    transition: left 0.3s ease;
    font-size: 1.2rem;
}

.play-btn:hover::before {
    left: 20px;
}

.play-btn:hover {
    background-position: right center;
    transform: scale(1.05);
    box-shadow: 
        0 15px 30px rgba(255, 107, 107, 0.4),
        0 5px 15px rgba(0, 0, 0, 0.2);
    padding-left: 3rem;
}

.game-screen {
    display: none;
    background: rgba(0, 0, 0, 0.95);
    backdrop-filter: blur(10px);
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1000;
    padding: 2rem;
    animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.game-container {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
    backdrop-filter: blur(20px);
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 25px;
    padding: 2rem;
    max-width: 900px;
    margin: 0 auto;
    height: 90vh;
    position: relative;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
}

.close-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: linear-gradient(45deg, #ff6b6b, #ff8e53);
    border: none;
    color: white;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 1.8rem;
    z-index: 10;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
}

.close-btn:hover {
    transform: scale(1.1) rotate(90deg);
    box-shadow: 0 8px 25px rgba(255, 107, 107, 0.5);
}

.game-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
    position: relative;
}

.score-board {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
    font-weight: bold;
    color: white;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    padding: 1rem 2rem;
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

#snake-canvas {
    border: 3px solid #4ecdc4;
    border-radius: 15px;
    background: #000;
    box-shadow: 
        0 0 30px rgba(78, 205, 196, 0.5),
        inset 0 0 20px rgba(0, 0, 0, 0.5);
}

.game-controls {
    margin-top: 1.5rem;
    text-align: center;
    color: rgba(255, 255, 255, 0.8);
    font-size: 1.1rem;
    background: rgba(255, 255, 255, 0.1);
    padding: 1rem 2rem;
    border-radius: 15px;
    backdrop-filter: blur(10px);
}

.memory-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
    max-width: 450px;
    margin: 1rem auto;
    perspective: 1000px;
}

.memory-card {
    width: 90px;
    height: 90px;
    background: linear-gradient(45deg, #667eea, #764ba2);
    border-radius: 15px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2.5rem;
    transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    border: 3px solid transparent;
    transform-style: preserve-3d;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
}

.memory-card:hover {
    transform: rotateY(10deg) scale(1.05);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3);
}

.memory-card.flipped {
    background: linear-gradient(45deg, #fff, #f8f9fa);
    color: #333;
    border-color: #4ecdc4;
    transform: rotateY(180deg) scale(1.05);
    box-shadow: 0 15px 30px rgba(78, 205, 196, 0.3);
}

.memory-card.matched {
    background: linear-gradient(45deg, #4caf50, #45a049);
    color: white;
    transform: scale(1.1);
    animation: matchedPulse 0.6s ease-in-out;
}

@keyframes matchedPulse {
    0%, 100% { transform: scale(1.1); }
    50% { transform: scale(1.2); }
}

.welcome-section {
    text-align: center;
    margin-bottom: 4rem;
    position: relative;
}

.welcome-title {
    font-size: 4rem;
    font-weight: bold;
    margin-bottom: 1rem;
    background: linear-gradient(45deg, #ff6b6b, #ffd93d, #4ecdc4, #45b7d1);
    background-size: 300% 300%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: gradientText 4s ease infinite;
    text-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
}

@keyframes gradientText {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

.welcome-subtitle {
    font-size: 1.3rem;
    opacity: 0.9;
    animation: fadeInUp 1s ease-out 0.5s both;
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 0.9;
        transform: translateY(0);
    }
}

/* Enhanced Quiz Styles */
.quiz-question {
    text-align: center;
    margin-bottom: 2rem;
    padding: 2rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 20px;
    backdrop-filter: blur(10px);
}

.quiz-options {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    max-width: 600px;
    margin: 0 auto;
}

.quiz-option {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    padding: 1.5rem;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    color: white;
    font-weight: 600;
    backdrop-filter: blur(10px);
}

.quiz-option:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: #4ecdc4;
    transform: translateY(-3px);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
}

.quiz-option.correct {
    background: linear-gradient(45deg, #4caf50, #45a049);
    color: white;
    border-color: #4caf50;
    animation: correctPulse 0.6s ease-in-out;
}

.quiz-option.wrong {
    background: linear-gradient(45deg, #f44336, #d32f2f);
    color: white;
    border-color: #f44336;
    animation: wrongShake 0.6s ease-in-out;
}

@keyframes correctPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

@keyframes wrongShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

/* Enhanced Typing Styles */
.typing-text {
    background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
    color: #e0e0e0;
    padding: 2rem;
    border-radius: 20px;
    font-family: 'Courier New', monospace;
    font-size: 1.4rem;
    line-height: 1.8;
    margin-bottom: 2rem;
    border: 2px solid #4ecdc4;
    max-width: 800px;
    min-height: 180px;
    text-align: left;
    box-shadow: 
        0 20px 40px rgba(0, 0, 0, 0.3),
        inset 0 0 20px rgba(78, 205, 196, 0.1);
}

.typing-text .correct {
    background: #4caf50;
    color: white;
    border-radius: 3px;
    padding: 0 2px;
}

.typing-text .incorrect {
    background: #f44336;
    color: white;
    border-radius: 3px;
    padding: 0 2px;
}

.typing-text .current {
    background: #ffd93d;
    color: #333;
    border-radius: 3px;
    padding: 0 2px;
    animation: typingBlink 1s infinite;
}

@keyframes typingBlink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0.3; }
}

/* Reaction Test Styles */
.reaction-circle {
    width: 250px;
    height: 250px;
    border-radius: 50%;
    margin: 2rem auto;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.4rem;
    font-weight: bold;
    transition: all 0.3s ease;
    border: 5px solid rgba(255, 255, 255, 0.2);
    box-shadow: 
        0 20px 40px rgba(0, 0, 0, 0.3),
        inset 0 0 20px rgba(255, 255, 255, 0.1);
}

.reaction-circle.waiting {
    background: linear-gradient(45deg, #f44336, #d32f2f);
    animation: waitingPulse 2s ease-in-out infinite;
}

.reaction-circle.ready {
    background: linear-gradient(45deg, #4caf50, #45a049);
    animation: readyGlow 0.3s ease-in-out;
}

.reaction-circle.clicked {
    background: linear-gradient(45deg, #2196f3, #1976d2);
    animation: clickedBurst 0.3s ease-out;
}

@keyframes waitingPulse {
    0%, 100% { transform: scale(1); box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3); }
    50% { transform: scale(1.05); box-shadow: 0 25px 50px rgba(244, 67, 54, 0.4); }
}

@keyframes readyGlow {
    from { transform: scale(1); }
    to { transform: scale(1.1); box-shadow: 0 30px 60px rgba(76, 175, 80, 0.6); }
}

@keyframes clickedBurst {
    0% { transform: scale(1.1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1.05); }
}

/* Pong Canvas Style */
#pong-canvas {
    border: 3px solid #4ecdc4;
    border-radius: 15px;
    background: #000;
    box-shadow: 
        0 0 30px rgba(78, 205, 196, 0.5),
        inset 0 0 20px rgba(0, 0, 0, 0.5);
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
    .game-grid {
        grid-template-columns: 1fr;
        gap: 2rem;
    }
    
    .welcome-title {
        font-size: 2.5rem;
    }
    
    .game-container {
        height: 95vh;
        padding: 1rem;
    }
    
    .memory-grid {
        grid-template-columns: repeat(3, 1fr);
        max-width: 300px;
    }
    
    .memory-card {
        width: 70px;
        height: 70px;
        font-size: 2rem;
    }
    
    .quiz-options {
        grid-template-columns: 1fr;
    }
}

/* Loading Animation */
.loading {
    display: inline-block;
    width: 40px;
    height: 40px;
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #4ecdc4;
    animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Typing Game Styles */
.typing-input {
    padding: 1.5rem;
    font-size: 1.3rem;
    border: 3px solid #4ecdc4;
    border-radius: 15px;
    width: 100%;
    max-width: 600px;
    text-align: left;
    font-family: 'Courier New', monospace;
    background: rgba(255, 255, 255, 0.95);
    color: #333;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.typing-input:focus {
    outline: none;
    border-color: #ffd93d;
    box-shadow: 0 0 20px rgba(255, 217, 61, 0.4);
    transform: scale(1.02);
}

.typing-stats {
    display: flex;
    gap: 3rem;
    margin-top: 2rem;
    flex-wrap: wrap;
    justify-content: center;
}

.stat {
    text-align: center;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    padding: 1.5rem;
    border-radius: 15px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    min-width: 120px;
    transition: all 0.3s ease;
}

.stat:hover {
    background: rgba(255, 255, 255, 0.15);
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

.stat-value {
    font-size: 2.5rem;
    font-weight: bold;
    background: linear-gradient(45deg, #ffd93d, #ff8e53);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    margin-bottom: 0.5rem;
    display: block;
    animation: statGlow 2s ease-in-out infinite alternate;
}

@keyframes statGlow {
    from { filter: drop-shadow(0 0 5px rgba(255, 217, 61, 0.3)); }
    to { filter: drop-shadow(0 0 15px rgba(255, 217, 61, 0.6)); }
}

.typing-reset-btn {
    background: linear-gradient(45deg, #667eea, #764ba2);
    border: none;
    color: white;
    padding: 1rem 2rem;
    border-radius: 25px;
    cursor: pointer;
    font-weight: bold;
    font-size: 1.1rem;
    margin-top: 2rem;
    transition: all 0.4s ease;
    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.typing-reset-btn:hover {
    transform: scale(1.05) translateY(-2px);
    box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
    background: linear-gradient(45deg, #764ba2, #667eea);
}

/* Quiz Game Styles */
.category-selection {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
    max-width: 900px;
    margin-left: auto;
    margin-right: auto;
}

.category-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: white;
    padding: 1.5rem 1rem;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    font-size: 1.1rem;
    font-weight: 600;
    backdrop-filter: blur(15px);
    text-align: center;
    position: relative;
    overflow: hidden;
}

.category-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: left 0.6s ease;
}

.category-btn:hover::before {
    left: 100%;
}

.category-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: #4ecdc4;
    transform: translateY(-5px) scale(1.02);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
}

.category-btn.selected {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    border-color: #4ecdc4;
    color: white;
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 15px 30px rgba(78, 205, 196, 0.4);
    animation: selectedPulse 2s ease-in-out infinite;
}

@keyframes selectedPulse {
    0%, 100% { box-shadow: 0 15px 30px rgba(78, 205, 196, 0.4); }
    50% { box-shadow: 0 20px 40px rgba(78, 205, 196, 0.6); }
}

.start-quiz-btn {
    background: linear-gradient(45deg, #4caf50, #45a049);
    border: none;
    color: white;
    padding: 1.5rem 3rem;
    border-radius: 30px;
    cursor: pointer;
    font-size: 1.3rem;
    font-weight: bold;
    margin-top: 2rem;
    transition: all 0.4s ease;
    text-transform: uppercase;
    letter-spacing: 2px;
    box-shadow: 0 10px 25px rgba(76, 175, 80, 0.3);
    position: relative;
    overflow: hidden;
}

.start-quiz-btn::before {
    content: '🚀';
    position: absolute;
    left: -40px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 1.5rem;
    transition: left 0.4s ease;
}

.start-quiz-btn:hover::before {
    left: 30px;
}

.start-quiz-btn:hover {
    transform: scale(1.08) translateY(-3px);
    box-shadow: 0 20px 40px rgba(76, 175, 80, 0.5);
    background: linear-gradient(45deg, #45a049, #4caf50);
    padding-left: 4rem;
}

.start-quiz-btn:active {
    transform: scale(1.05) translateY(-1px);
    box-shadow: 0 15px 30px rgba(76, 175, 80, 0.4);
}

/* Difficulty Selection Styles (if you plan to add it back) */
.difficulty-selection {
    display: flex;
    gap: 1.5rem;
    margin: 2rem 0;
    justify-content: center;
    flex-wrap: wrap;
}

.difficulty-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: white;
    padding: 1rem 2rem;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    font-weight: 600;
    min-width: 120px;
}

.difficulty-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
}

.difficulty-btn.selected {
    background: linear-gradient(45deg, #667eea, #764ba2);
    border-color: #667eea;
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
}

/* Mobile Responsiveness for these elements */
@media (max-width: 768px) {
    .category-selection {
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
    }
    
    .category-btn {
        padding: 1rem 0.5rem;
        font-size: 1rem;
    }
    
    .typing-stats {
        gap: 1.5rem;
    }
    
    .stat {
        min-width: 100px;
        padding: 1rem;
    }
    
    .stat-value {
        font-size: 2rem;
    }
    
    .start-quiz-btn {
        padding: 1.2rem 2rem;
        font-size: 1.1rem;
    }
    
    .difficulty-selection {
        flex-direction: column;
        align-items: center;
    }
    
    .difficulty-btn {
        min-width: 200px;
    }
}
/* Extra animations for enhanced interactivity */
@keyframes fadeInScale {
    from {
        opacity: 0;
        transform: scale(0.8);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

@keyframes slideInFromBottom {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Apply entrance animations */
.typing-stats .stat {
    animation: fadeInScale 0.6s ease-out forwards;
}

.typing-stats .stat:nth-child(1) { animation-delay: 0.1s; }
.typing-stats .stat:nth-child(2) { animation-delay: 0.2s; }
.typing-stats .stat:nth-child(3) { animation-delay: 0.3s; }

.category-btn {
    animation: slideInFromBottom 0.6s ease-out forwards;
}

.category-btn:nth-child(1) { animation-delay: 0.1s; }
.category-btn:nth-child(2) { animation-delay: 0.2s; }
.category-btn:nth-child(3) { animation-delay: 0.3s; }
.category-btn:nth-child(4) { animation-delay: 0.4s; }



/* Math Blaster Styles */
.math-game {
    text-align: center;
    width: 100%;
    max-width: 600px;
}

.math-question {
    font-size: 3rem;
    font-weight: bold;
    color: white;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(15px);
    padding: 2rem;
    border-radius: 20px;
    margin-bottom: 2rem;
    border: 2px solid rgba(78, 205, 196, 0.3);
    animation: questionGlow 2s ease-in-out infinite alternate;
    min-height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
}

@keyframes questionGlow {
    from { box-shadow: 0 0 20px rgba(78, 205, 196, 0.3); }
    to { box-shadow: 0 0 30px rgba(78, 205, 196, 0.6); }
}

.math-options {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-bottom: 2rem;
}

.math-option {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: white;
    padding: 1.5rem;
    border-radius: 15px;
    cursor: pointer;
    font-size: 1.5rem;
    font-weight: bold;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
}

.math-option:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: #4ecdc4;
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

.math-option.correct {
    background: linear-gradient(45deg, #4caf50, #45a049);
    border-color: #4caf50;
    animation: correctBounce 0.6s ease-in-out;
}

.math-option.wrong {
    background: linear-gradient(45deg, #f44336, #d32f2f);
    border-color: #f44336;
    animation: wrongShake 0.6s ease-in-out;
}

@keyframes correctBounce {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.15); }
}

@keyframes wrongShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px); }
    75% { transform: translateX(10px); }
}

.math-stats {
    display: flex;
    gap: 2rem;
    justify-content: center;
    margin: 2rem 0;
}

.start-game-btn {
    background: linear-gradient(45deg, #667eea, #764ba2);
    border: none;
    color: white;
    padding: 1.5rem 3rem;
    border-radius: 30px;
    cursor: pointer;
    font-size: 1.2rem;
    font-weight: bold;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.start-game-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
}

/* Aim Trainer Styles */
.aim-game {
    text-align: center;
    width: 100%;
}

.aim-playground {
    width: 100%;
    height: 400px;
    background: linear-gradient(45deg, #1a1a2e, #16213e);
    border: 3px solid #4ecdc4;
    border-radius: 20px;
    position: relative;
    overflow: hidden;
    cursor: none;
    margin-bottom: 2rem;
    box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.5);
}

.aim-target {
    position: absolute;
    width: 60px;
    height: 60px;
    background: radial-gradient(circle, #ff6b6b 0%, #ff8e53 50%, #ff6b6b 100%);
    border-radius: 50%;
    cursor: crosshair;
    animation: targetPulse 1s ease-in-out infinite;
    border: 3px solid rgba(255, 255, 255, 0.8);
    box-shadow: 0 0 20px rgba(255, 107, 107, 0.6);
}

@keyframes targetPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

.crosshair {
    position: absolute;
    color: #4ecdc4;
    font-size: 2rem;
    font-weight: bold;
    pointer-events: none;
    z-index: 10;
    text-shadow: 0 0 10px rgba(78, 205, 196, 0.8);
    transform: translate(-50%, -50%);
}

.aim-stats {
    display: flex;
    gap: 3rem;
    justify-content: center;
    margin: 2rem 0;
}

.hit-effect {
    position: absolute;
    color: #4caf50;
    font-size: 2rem;
    font-weight: bold;
    animation: hitEffect 0.8s ease-out forwards;
    pointer-events: none;
    z-index: 20;
}

@keyframes hitEffect {
    0% {
        opacity: 1;
        transform: scale(1);
    }
    100% {
        opacity: 0;
        transform: scale(2) translateY(-30px);
    }
}

.miss-effect {
    position: absolute;
    color: #f44336;
    font-size: 1.5rem;
    font-weight: bold;
    animation: missEffect 0.6s ease-out forwards;
    pointer-events: none;
    z-index: 20;
}

@keyframes missEffect {
    0% {
        opacity: 1;
        transform: scale(1);
    }
    100% {
        opacity: 0;
        transform: scale(1.5) translateY(-20px);
    }
}

/* Color Match Styles */
.color-game {
    text-align: center;
    width: 100%;
    max-width: 700px;
}

.color-instruction {
    background: rgba(255, 217, 61, 0.1);
    border: 2px solid #ffd93d;
    color: #ffd93d;
    padding: 1rem 2rem;
    border-radius: 15px;
    margin-bottom: 2rem;
    font-weight: bold;
    font-size: 1.1rem;
    animation: instructionGlow 2s ease-in-out infinite alternate;
}

@keyframes instructionGlow {
    from { box-shadow: 0 0 15px rgba(255, 217, 61, 0.3); }
    to { box-shadow: 0 0 25px rgba(255, 217, 61, 0.6); }
}

.color-display {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(15px);
    border: 3px solid rgba(255, 255, 255, 0.2);
    border-radius: 25px;
    padding: 3rem 2rem;
    margin-bottom: 2rem;
    min-height: 150px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.color-word {
    font-size: 4rem;
    font-weight: bold;
    text-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    animation: wordBounce 0.6s ease-in-out;
}

@keyframes wordBounce {
    0% { transform: scale(0.8); opacity: 0; }
    50% { transform: scale(1.1); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
}

.color-options {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1rem;
    margin-bottom: 2rem;
}

.color-option {
    aspect-ratio: 1;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 4px solid rgba(255, 255, 255, 0.3);
    position: relative;
    overflow: hidden;
}

.color-option:hover {
    transform: translateY(-5px) scale(1.05);
    border-color: rgba(255, 255, 255, 0.8);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
}

.color-option.correct {
    animation: correctColor 0.6s ease-in-out;
}

.color-option.wrong {
    animation: wrongColor 0.6s ease-in-out;
}

@keyframes correctColor {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); box-shadow: 0 0 30px rgba(76, 175, 80, 0.8); }
}

@keyframes wrongColor {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px) rotate(-2deg); }
    75% { transform: translateX(10px) rotate(2deg); }
}

.color-stats {
    display: flex;
    gap: 2rem;
    justify-content: center;
    margin: 2rem 0;
}

/* Lives indicator */
.lives-indicator {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    font-size: 1.5rem;
}

.heart {
    color: #ff6b6b;
    animation: heartBeat 1s ease-in-out infinite;
}

@keyframes heartBeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

/* Word Scramble Styles */
.word-game {
    text-align: center;
    width: 100%;
    max-width: 700px;
}

.word-category {
    background: linear-gradient(45deg, #667eea, #764ba2);
    color: white;
    padding: 1rem 2rem;
    border-radius: 25px;
    font-size: 1.2rem;
    font-weight: bold;
    margin-bottom: 2rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
}

.scrambled-word {
    font-size: 3.5rem;
    font-weight: bold;
    color: white;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(15px);
    padding: 2rem;
    border-radius: 20px;
    margin-bottom: 2rem;
    border: 3px solid rgba(255, 217, 61, 0.5);
    letter-spacing: 8px;
    animation: letterFloat 2s ease-in-out infinite alternate;
    min-height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

@keyframes letterFloat {
    from { transform: translateY(0px); box-shadow: 0 5px 15px rgba(255, 217, 61, 0.3); }
    to { transform: translateY(-10px); box-shadow: 0 15px 30px rgba(255, 217, 61, 0.6); }
}

.word-input-section {
    display: flex;
    gap: 1rem;
    margin-bottom: 2rem;
    justify-content: center;
    align-items: center;
}

.word-input {
    padding: 1.5rem;
    font-size: 1.4rem;
    border: 3px solid #4ecdc4;
    border-radius: 15px;
    background: rgba(255, 255, 255, 0.95);
    color: #333;
    flex: 1;
    max-width: 400px;
    text-align: center;
    font-weight: bold;
    transition: all 0.3s ease;
    text-transform: uppercase;
}

.word-input:focus {
    outline: none;
    border-color: #ffd93d;
    box-shadow: 0 0 20px rgba(255, 217, 61, 0.4);
    transform: scale(1.02);
}

.word-submit-btn {
    background: linear-gradient(45deg, #4caf50, #45a049);
    border: none;
    color: white;
    padding: 1.5rem 2rem;
    border-radius: 15px;
    cursor: pointer;
    font-size: 1.2rem;
    font-weight: bold;
    transition: all 0.3s ease;
    text-transform: uppercase;
}

.word-submit-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 10px 25px rgba(76, 175, 80, 0.4);
}

.word-hint {
    background: rgba(255, 217, 61, 0.1);
    border: 2px solid #ffd93d;
    border-radius: 15px;
    padding: 1rem;
    margin-bottom: 2rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
}

.hint-btn {
    background: linear-gradient(45deg, #ffd93d, #ff8e53);
    border: none;
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: 25px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s ease;
}

.hint-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 5px 15px rgba(255, 217, 61, 0.4);
}

.word-stats {
    display: flex;
    gap: 2rem;
    justify-content: center;
    margin: 2rem 0;
}

.skip-btn {
    background: linear-gradient(45deg, #ff6b6b, #ff8e53);
    border: none;
    color: white;
    padding: 1rem 2rem;
    border-radius: 25px;
    cursor: pointer;
    font-weight: bold;
    margin-top: 1rem;
    transition: all 0.3s ease;
}

.skip-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
}

.word-correct {
    animation: correctWord 0.8s ease-in-out;
}

@keyframes correctWord {
    0%, 100% { transform: scale(1) rotate(0deg); }
    25% { transform: scale(1.1) rotate(2deg); }
    75% { transform: scale(1.1) rotate(-2deg); }
}

.word-wrong {
    animation: wrongWord 0.6s ease-in-out;
}

@keyframes wrongWord {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-15px); }
    75% { transform: translateX(15px); }
}


/* 2048 Game Styles */
.game2048 {
    text-align: center;
    width: 100%;
    max-width: 600px;
}

.game2048-instructions {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    padding: 1rem;
    border-radius: 15px;
    margin-bottom: 2rem;
    color: rgba(255, 255, 255, 0.9);
    font-size: 1.1rem;
}

.game2048-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    background: rgba(0, 0, 0, 0.3);
    padding: 15px;
    border-radius: 20px;
    margin-bottom: 2rem;
    backdrop-filter: blur(10px);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
}

.game2048-cell {
    aspect-ratio: 1;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    font-weight: bold;
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.1);
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    position: relative;
    overflow: hidden;
}

.game2048-cell.tile-2 {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    color: white;
    box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
}

.game2048-cell.tile-4 {
    background: linear-gradient(45deg, #45b7d1, #2980b9);
    color: white;
    box-shadow: 0 5px 15px rgba(69, 183, 209, 0.3);
}

.game2048-cell.tile-8 {
    background: linear-gradient(45deg, #f9ca24, #f0932b);
    color: white;
    box-shadow: 0 5px 15px rgba(249, 202, 36, 0.3);
}

.game2048-cell.tile-16 {
    background: linear-gradient(45deg, #ff8e53, #ff6b6b);
    color: white;
    box-shadow: 0 5px 15px rgba(255, 142, 83, 0.3);
}

.game2048-cell.tile-32 {
    background: linear-gradient(45deg, #ff6b9d, #c44569);
    color: white;
    box-shadow: 0 5px 15px rgba(255, 107, 157, 0.3);
}

.game2048-cell.tile-64 {
    background: linear-gradient(45deg, #a55eea, #8854d0);
    color: white;
    box-shadow: 0 5px 15px rgba(165, 94, 234, 0.3);
}

.game2048-cell.tile-128 {
    background: linear-gradient(45deg, #fd79a8, #e84393);
    color: white;
    font-size: 1.7rem;
    box-shadow: 0 5px 15px rgba(253, 121, 168, 0.3);
}

.game2048-cell.tile-256 {
    background: linear-gradient(45deg, #fdcb6e, #e17055);
    color: white;
    font-size: 1.7rem;
    box-shadow: 0 8px 20px rgba(253, 203, 110, 0.4);
}

.game2048-cell.tile-512 {
    background: linear-gradient(45deg, #6c5ce7, #a29bfe);
    color: white;
    font-size: 1.7rem;
    box-shadow: 0 8px 20px rgba(108, 92, 231, 0.4);
}

.game2048-cell.tile-1024 {
    background: linear-gradient(45deg, #00b894, #00a085);
    color: white;
    font-size: 1.4rem;
    box-shadow: 0 10px 25px rgba(0, 184, 148, 0.5);
}

.game2048-cell.tile-2048 {
    background: linear-gradient(45deg, #ffd93d, #ff8e53);
    color: white;
    font-size: 1.4rem;
    box-shadow: 0 15px 30px rgba(255, 217, 61, 0.6);
    animation: tile2048Glow 2s ease-in-out infinite alternate;
}

@keyframes tile2048Glow {
    from { box-shadow: 0 15px 30px rgba(255, 217, 61, 0.6); }
    to { box-shadow: 0 20px 40px rgba(255, 217, 61, 0.9); }
}

.game2048-cell.new-tile {
    animation: newTile 0.3s ease-in-out;
}

@keyframes newTile {
    from { transform: scale(0); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

.game2048-cell.merged-tile {
    animation: mergeTile 0.3s ease-in-out;
}

@keyframes mergeTile {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
}

.game2048-controls {
    display: flex;
    gap: 1rem;
    justify-content: center;
    margin-bottom: 2rem;
}

.game2048-btn {
    background: linear-gradient(45deg, #667eea, #764ba2);
    border: none;
    color: white;
    padding: 1rem 2rem;
    border-radius: 25px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s ease;
    text-transform: uppercase;
}

.game2048-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
}

.game2048-status {
    font-size: 1.5rem;
    font-weight: bold;
    color: #ffd93d;
    text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

/* Flappy Bird Styles */
.flappy-game {
    text-align: center;
    width: 100%;
}

#flappy-canvas {
    border: 3px solid #4ecdc4;
    border-radius: 20px;
    background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 100%);
    box-shadow: 
        0 0 30px rgba(78, 205, 196, 0.5),
        inset 0 0 50px rgba(255, 255, 255, 0.1);
    cursor: pointer;
    margin-bottom: 1rem;
}

.flappy-instructions {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(15px);
    color: white;
    padding: 2rem;
    border-radius: 20px;
    font-size: 1.3rem;
    text-align: center;
    border: 2px solid rgba(255, 255, 255, 0.3);
    z-index: 10;
}

.flappy-controls {
    margin-top: 1rem;
}

.control-hint {
    color: rgba(255, 255, 255, 0.8);
    font-size: 1.1rem;
    background: rgba(255, 255, 255, 0.1);
    padding: 1rem;
    border-radius: 15px;
    backdrop-filter: blur(10px);
}

.game-over-screen {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(20px);
    color: white;
    padding: 3rem;
    border-radius: 25px;
    text-align: center;
    border: 3px solid rgba(255, 107, 107, 0.5);
    z-index: 20;
}

.final-score {
    font-size: 2rem;
    color: #ffd93d;
    margin: 1rem 0;
    font-weight: bold;
}

.play-again-btn {
    background: linear-gradient(45deg, #4caf50, #45a049);
    border: none;
    color: white;
    padding: 1rem 2rem;
    border-radius: 25px;
    cursor: pointer;
    font-size: 1.2rem;
    font-weight: bold;
    margin-top: 1rem;
    transition: all 0.3s ease;
}

.play-again-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 10px 25px rgba(76, 175, 80, 0.4);
}

@media (max-width: 768px) {
    .word-input-section {
        flex-direction: column;
    }
    
    .word-input {
        max-width: 100%;
        margin-bottom: 1rem;
    }
    
    .game2048-grid {
        max-width: 350px;
        margin: 0 auto 2rem;
    }
    
    .game2048-cell {
        font-size: 1.5rem;
    }
    
    #flappy-canvas {
        max-width: 100%;
        height: auto;
    }
}


/* Asteroids Mini Styles */
.asteroids-game {
    text-align: center;
    width: 100%;
}

#asteroids-canvas {
    border: 3px solid #4ecdc4;
    border-radius: 15px;
    background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
    box-shadow: 
        0 0 30px rgba(78, 205, 196, 0.5),
        inset 0 0 50px rgba(0, 0, 0, 0.8);
    margin-bottom: 1rem;
    position: relative;
}

.asteroids-instructions {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(20px);
    color: white;
    padding: 3rem;
    border-radius: 25px;
    text-align: center;
    border: 3px solid rgba(78, 205, 196, 0.5);
    z-index: 10;
    max-width: 500px;
}

.control-instructions {
    margin-bottom: 2rem;
    font-size: 1.1rem;
    line-height: 2;
}

.control-instructions > div {
    background: rgba(255, 255, 255, 0.1);
    padding: 0.75rem;
    margin: 0.5rem 0;
    border-radius: 10px;
    backdrop-filter: blur(10px);
}

.asteroids-stats {
    display: flex;
    gap: 3rem;
    justify-content: center;
    margin: 2rem 0;
}

.asteroids-hud {
    position: absolute;
    top: 20px;
    left: 20px;
    color: #4ecdc4;
    font-family: 'Courier New', monospace;
    font-size: 1.2rem;
    font-weight: bold;
    text-shadow: 0 0 10px rgba(78, 205, 196, 0.8);
    z-index: 5;
}

.weapon-overheated {
    color: #ff6b6b !important;
    animation: overheatBlink 0.5s ease-in-out infinite alternate;
}

@keyframes overheatBlink {
    from { opacity: 1; }
    to { opacity: 0.3; }
}

.level-complete {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(76, 175, 80, 0.9);
    backdrop-filter: blur(15px);
    color: white;
    padding: 2rem;
    border-radius: 20px;
    font-size: 1.5rem;
    font-weight: bold;
    text-align: center;
    border: 3px solid #4caf50;
    z-index: 15;
    animation: levelCompleteScale 0.6s ease-in-out;
}

@keyframes levelCompleteScale {
    0% { transform: translate(-50%, -50%) scale(0); }
    50% { transform: translate(-50%, -50%) scale(1.1); }
    100% { transform: translate(-50%, -50%) scale(1); }
}

.game-over-asteroids {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(244, 67, 54, 0.9);
    backdrop-filter: blur(20px);
    color: white;
    padding: 3rem;
    border-radius: 25px;
    text-align: center;
    border: 3px solid #f44336;
    z-index: 20;
}

.final-stats {
    margin: 1.5rem 0;
    font-size: 1.2rem;
}

.play-again-asteroids {
    background: linear-gradient(45deg, #4caf50, #45a049);
    border: none;
    color: white;
    padding: 1rem 2rem;
    border-radius: 25px;
    cursor: pointer;
    font-size: 1.2rem;
    font-weight: bold;
    margin-top: 1rem;
    transition: all 0.3s ease;
}

.play-again-asteroids:hover {
    transform: scale(1.05);
    box-shadow: 0 10px 25px rgba(76, 175, 80, 0.4);
}

/* Thrust effect */
.thrust-active {
    box-shadow: 
        0 0 30px rgba(78, 205, 196, 0.5),
        inset 0 0 50px rgba(0, 0, 0, 0.8),
        0 0 60px rgba(255, 165, 0, 0.4) !important;
}


/* Pixel Art Creator Styles */
.pixel-art-game {
    width: 100%;
    height: 100%;
}

.pixel-art-container {
    display: flex;
    gap: 2rem;
    height: 100%;
    max-height: calc(90vh - 200px);
}

.pixel-toolbar {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(15px);
    border-radius: 20px;
    padding: 1.5rem;
    width: 250px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    overflow-y: auto;
    max-height: 100%;
}

.pixel-toolbar h4 {
    color: #ffd93d;
    margin-bottom: 1rem;
    font-size: 1.1rem;
    text-align: center;
}

.tool-section, .color-section, .grid-section, .action-section {
    margin-bottom: 2rem;
    padding-bottom: 1.5rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.tool-buttons, .grid-buttons, .action-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.5rem;
}

.tool-btn, .grid-btn, .action-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: white;
    padding: 0.75rem 0.5rem;
    border-radius: 10px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
}

.tool-btn:hover, .grid-btn:hover, .action-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: #4ecdc4;
    transform: translateY(-2px);
}

.tool-btn.active, .grid-btn.active {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    border-color: #4ecdc4;
    color: white;
}

.color-palette {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.color-swatch {
    width: 40px;
    height: 40px;
    border-radius: 8px;
    cursor: pointer;
    border: 3px solid rgba(255, 255, 255, 0.3);
    transition: all 0.3s ease;
    position: relative;
}

.color-swatch:hover {
    transform: scale(1.1);
    border-color: rgba(255, 255, 255, 0.8);
}

.color-swatch.active {
    border-color: #ffd93d;
    box-shadow: 0 0 15px rgba(255, 217, 61, 0.6);
    transform: scale(1.1);
}

.color-inputs {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.custom-color-input {
    width: 50px;
    height: 30px;
    border-radius: 5px;
    border: none;
    cursor: pointer;
}

.canvas-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
}

#pixel-canvas {
    border: 3px solid #4ecdc4;
    border-radius: 15px;
    background: white;
    cursor: crosshair;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
}

.canvas-info {
    display: flex;
    gap: 2rem;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    padding: 1rem 2rem;
    border-radius: 15px;
    color: white;
    font-family: 'Courier New', monospace;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.template-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.template-content {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(20px);
    border-radius: 20px;
    padding: 2rem;
    border: 2px solid rgba(255, 255, 255, 0.2);
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
}

.template-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 1rem;
    margin: 1rem 0;
}

.template-item {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    padding: 1rem;
    cursor: pointer;
    text-align: center;
    color: white;
    transition: all 0.3s ease;
}

.template-item:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: #4ecdc4;
    transform: translateY(-2px);
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
    .pixel-art-container {
        flex-direction: column;
        height: auto;
    }
    
    .pixel-toolbar {
        width: 100%;
        max-height: 200px;
        padding: 1rem;
    }
    
    .tool-buttons, .grid-buttons, .action-buttons {
        grid-template-columns: repeat(4, 1fr);
    }
    
    .color-palette {
        grid-template-columns: repeat(6, 1fr);
    }
    
    #pixel-canvas {
        max-width: 100%;
        height: auto;
    }
    
    .canvas-info {
        flex-direction: column;
        gap: 0.5rem;
        text-align: center;
    }
}

@media (max-width: 768px) {
    #asteroids-canvas {
        max-width: 100%;
        height: auto;
    }
    
    .control-instructions {
        font-size: 1rem;
    }
    
    .asteroids-stats {
        gap: 1.5rem;
        flex-wrap: wrap;
    }
    
    .pixel-art-container {
        flex-direction: column;
        height: auto;
    }
    
    .pixel-toolbar {
        width: 100%;
        max-height: none;
        padding: 1rem;
        order: 2;
    }
    
    .canvas-container {
        order: 1;
    }
    
    #pixel-canvas {
        max-width: 100%;
        height: auto;
    }
    
    .tool-buttons, .grid-buttons, .action-buttons {
        grid-template-columns: repeat(4, 1fr);
    }
    
    .color-palette {
        grid-template-columns: repeat(6, 1fr);
    }
}

/* Hidden Object Game Styles */
.hidden-object-game {
    display: flex;
    gap: 2rem;
    height: 100%;
    max-height: calc(90vh - 200px);
}

.hidden-scene-container {
    flex: 1;
    position: relative;
    border-radius: 15px;
    overflow: hidden;
    background: linear-gradient(135deg, #667eea, #764ba2);
    border: 3px solid #4ecdc4;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
}

.hidden-scene {
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #74b9ff, #0984e3, #6c5ce7);
    position: relative;
    cursor: crosshair;
    transition: transform 0.3s ease;
    transform-origin: center;
    overflow: hidden;
    min-height: 500px;
}

.hidden-object {
    position: absolute;
    width: 40px;
    height: 40px;
    font-size: 2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 5;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(5px);
    border: 2px solid rgba(255, 255, 255, 0.3);
}

.hidden-object:hover {
    transform: scale(1.2);
    background: rgba(255, 255, 255, 0.2);
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
}

.hidden-object.found {
    background: linear-gradient(45deg, #4caf50, #45a049);
    border-color: #4caf50;
    transform: scale(1.3);
    animation: foundObject 0.6s ease-in-out;
    pointer-events: none;
}

@keyframes foundObject {
    0%, 100% { transform: scale(1.3); }
    50% { transform: scale(1.5); }
}

.hidden-object.hint-glow {
    animation: hintGlow 2s ease-in-out infinite;
}

@keyframes hintGlow {
    0%, 100% { box-shadow: 0 0 10px rgba(255, 217, 61, 0.5); }
    50% { box-shadow: 0 0 30px rgba(255, 217, 61, 1); }
}

.zoom-controls {
    position: absolute;
    top: 1rem;
    right: 1rem;
    display: flex;
    gap: 0.5rem;
    z-index: 10;
}

.zoom-btn {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 10px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.3s ease;
}

.zoom-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: #4ecdc4;
    transform: translateY(-2px);
}

.hidden-sidebar {
    width: 300px;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(15px);
    border-radius: 20px;
    padding: 1.5rem;
    border: 2px solid rgba(255, 255, 255, 0.2);
    display: flex;
    flex-direction: column;
    gap: 2rem;
}

.objects-to-find h3 {
    color: #ffd93d;
    margin-bottom: 1rem;
    text-align: center;
    font-size: 1.2rem;
}

.object-list {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.75rem;
    max-height: 200px;
    overflow-y: auto;
}

.object-item {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    padding: 0.75rem;
    text-align: center;
    transition: all 0.3s ease;
    color: white;
    font-size: 1.5rem;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
}

.object-item.found {
    background: linear-gradient(45deg, #4caf50, #45a049);
    border-color: #4caf50;
    transform: scale(1.05);
}

.object-item .object-name {
    font-size: 0.8rem;
    opacity: 0.8;
}

.game-progress {
    text-align: center;
}

.progress-bar {
    width: 100%;
    height: 20px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    overflow: hidden;
    border: 2px solid rgba(255, 255, 255, 0.2);
    margin-bottom: 0.5rem;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4ecdc4, #44a08d);
    width: 0%;
    transition: width 0.5s ease;
    border-radius: 8px;
}

.progress-text {
    color: white;
    font-weight: bold;
    font-size: 1.1rem;
}

.hidden-stats {
    display: flex;
    gap: 1rem;
    justify-content: space-around;
}

.hidden-controls {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.hint-btn {
    background: linear-gradient(45deg, #ffd93d, #ff8e53);
    border: none;
    color: white;
    padding: 1rem;
    border-radius: 15px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s ease;
    font-size: 1rem;
}

.hint-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 10px 25px rgba(255, 217, 61, 0.4);
}

.hint-btn:disabled {
    background: #666;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.click-effect {
    position: absolute;
    width: 60px;
    height: 60px;
    border: 3px solid #ff6b6b;
    border-radius: 50%;
    pointer-events: none;
    animation: clickRipple 0.6s ease-out forwards;
    z-index: 20;
}

@keyframes clickRipple {
    0% {
        transform: scale(0);
        opacity: 1;
    }
    100% {
        transform: scale(2);
        opacity: 0;
    }
}

.level-complete {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(76, 175, 80, 0.95);
    backdrop-filter: blur(20px);
    color: white;
    padding: 3rem;
    border-radius: 25px;
    text-align: center;
    border: 3px solid #4caf50;
    z-index: 100;
    animation: levelCompleteScale 0.8s ease-in-out;
}

@keyframes levelCompleteScale {
    0% { transform: translate(-50%, -50%) scale(0); }
    50% { transform: translate(-50%, -50%) scale(1.1); }
    100% { transform: translate(-50%, -50%) scale(1); }
}

/* Scene decorations */
.scene-tree {
    position: absolute;
    font-size: 4rem;
    z-index: 1;
    opacity: 0.7;
}

.scene-cloud {
    position: absolute;
    font-size: 3rem;
    z-index: 1;
    opacity: 0.5;
    animation: cloudFloat 10s ease-in-out infinite alternate;
}

@keyframes cloudFloat {
    from { transform: translateX(0); }
    to { transform: translateX(20px); }
}

.scene-building {
    position: absolute;
    z-index: 1;
    opacity: 0.6;
}
/* Tower Defense Game Styles */
.tower-defense-game {
    display: flex;
    gap: 2rem;
    height: 100%;
    max-height: calc(90vh - 200px);
}

.td-game-area {
    flex: 1;
    position: relative;
}

#td-canvas {
    border: 3px solid #4ecdc4;
    border-radius: 15px;
    background: linear-gradient(135deg, #2d5a27, #4a7c59);
    cursor: crosshair;
    box-shadow: 
        0 0 30px rgba(78, 205, 196, 0.5),
        inset 0 0 50px rgba(0, 0, 0, 0.3);
}

.wave-info {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    backdrop-filter: blur(20px);
    color: white;
    padding: 2rem;
    border-radius: 20px;
    text-align: center;
    border: 3px solid rgba(78, 205, 196, 0.5);
    z-index: 10;
}

.wave-status {
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 1rem;
    color: #ffd93d;
}

.start-wave-btn {
    background: linear-gradient(45deg, #4caf50, #45a049);
    border: none;
    color: white;
    padding: 1rem 2rem;
    border-radius: 25px;
    cursor: pointer;
    font-size: 1.2rem;
    font-weight: bold;
    transition: all 0.3s ease;
}

.start-wave-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 10px 25px rgba(76, 175, 80, 0.4);
}

.td-sidebar {
    width: 280px;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(15px);
    border-radius: 20px;
    padding: 1.5rem;
    border: 2px solid rgba(255, 255, 255, 0.2);
    display: flex;
    flex-direction: column;
    gap: 2rem;
    overflow-y: auto;
}

.tower-shop h3 {
    color: #ffd93d;
    margin-bottom: 1rem;
    text-align: center;
}

.tower-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
}

.tower-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 15px;
    padding: 1rem;
    cursor: pointer;
    text-align: center;
    transition: all 0.3s ease;
    color: white;
}

.tower-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: #4ecdc4;
    transform: translateY(-3px);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
}

.tower-btn.selected {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    border-color: #4ecdc4;
    transform: translateY(-3px);
}

.tower-btn.disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

.tower-icon {
    font-size: 2rem;
    margin-bottom: 0.5rem;
}

.tower-name {
    font-weight: bold;
    margin-bottom: 0.25rem;
    font-size: 0.9rem;
}

.tower-cost {
    color: #ffd93d;
    font-weight: bold;
    margin-bottom: 0.25rem;
    font-size: 0.8rem;
}

.tower-stats {
    font-size: 0.7rem;
    opacity: 0.8;
}

.selected-tower-info {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 15px;
    padding: 1rem;
    border: 2px solid rgba(255, 255, 255, 0.2);
}

.selected-tower-info h3 {
    color: #ffd93d;
    margin-bottom: 1rem;
    text-align: center;
}

.tower-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 1rem;
}

.upgrade-btn, .sell-btn {
    flex: 1;
    padding: 0.75rem;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s ease;
}

.upgrade-btn {
    background: linear-gradient(45deg, #667eea, #764ba2);
    color: white;
}

.sell-btn {
    background: linear-gradient(45deg, #ff6b6b, #ff8e53);
    color: white;
}

.upgrade-btn:hover, .sell-btn:hover {
    transform: scale(1.05);
}

.wave-progress h3 {
    color: #ffd93d;
    margin-bottom: 1rem;
    text-align: center;
}

.enemy-progress .progress-bar {
    width: 100%;
    height: 15px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    overflow: hidden;
    border: 1px solid rgba(255, 255, 255, 0.2);
    margin-bottom: 0.5rem;
}

.enemy-progress .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff6b6b, #ff8e53);
    transition: width 0.3s ease;
}

.enemy-progress .progress-text {
    color: white;
    text-align: center;
    font-size: 0.9rem;
}

.td-stats {
    display: flex;
    gap: 1rem;
    justify-content: space-around;
}

.build-mode {
    cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="rgba(78,205,196,0.5)" stroke="rgb(78,205,196)" stroke-width="2"/></svg>'), auto !important;
}

.tower-placement-valid {
    background: rgba(76, 175, 80, 0.3) !important;
}

.tower-placement-invalid {
    background: rgba(244, 67, 54, 0.3) !important;
}

.tower-range-indicator {
    position: absolute;
    border: 2px dashed rgba(78, 205, 196, 0.6);
    border-radius: 50%;
    pointer-events: none;
    background: rgba(78, 205, 196, 0.1);
}

.damage-number {
    position: absolute;
    color: #ff6b6b;
    font-weight: bold;
    font-size: 1.2rem;
    pointer-events: none;
    z-index: 20;
    animation: damageFloat 1s ease-out forwards;
}

@keyframes damageFloat {
    0% {
        opacity: 1;
        transform: translateY(0);
    }
    100% {
        opacity: 0;
        transform: translateY(-30px);
    }
}

.game-over-td {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(244, 67, 54, 0.95);
    backdrop-filter: blur(20px);
    color: white;
    padding: 3rem;
    border-radius: 25px;
    text-align: center;
    border: 3px solid #f44336;
    z-index: 100;
}

.victory-td {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(76, 175, 80, 0.95);
    backdrop-filter: blur(20px);
    color: white;
    padding: 3rem;
    border-radius: 25px;
    text-align: center;
    border: 3px solid #4caf50;
    z-index: 100;
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
    .tower-defense-game, .hidden-object-game {
        flex-direction: column;
        height: auto;
    }
    
    .td-sidebar, .hidden-sidebar {
        width: 100%;
        order: 2;
    }
    
    .td-game-area, .hidden-scene-container {
        order: 1;
    }
    
    #td-canvas {
        max-width: 100%;
        height: auto;
    }
    
    .tower-buttons {
        grid-template-columns: repeat(4, 1fr);
    }
    
    .object-list {
        grid-template-columns: repeat(3, 1fr);
    }
    
    .hidden-stats, .td-stats {
        gap: 0.5rem;
    }
}


/* Additional particle and effect animations */
@keyframes sparkleEffect {
    0% { transform: translate(0, 0) scale(1); opacity: 1; }
    100% { transform: translate(var(--sparkle-x), var(--sparkle-y)) scale(0); opacity: 0; }
}

@keyframes enemySpawn {
    0% { transform: scale(0); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
}

.enemy-spawn {
    animation: enemySpawn 0.3s ease-out;
}

.tower-build {
    animation: towerBuild 0.4s ease-out;
}

@keyframes towerBuild {
    0% { transform: scale(0) rotate(0deg); }
    50% { transform: scale(1.2) rotate(180deg); }
    100% { transform: scale(1) rotate(360deg); }
}

/* Improved mobile layout */
@media (max-width: 480px) {
    .hidden-scene {
        min-height: 300px;
    }
    
    .zoom-controls {
        flex-direction: column;
        gap: 0.25rem;
    }
    
    .zoom-btn {
        padding: 0.5rem;
        font-size: 0.8rem;
    }
    
    .tower-buttons {
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
    }
    
    .tower-btn {
        padding: 0.75rem 0.5rem;
    }
    
    .tower-icon {
        font-size: 1.5rem;
    }
    
    #td-canvas {
        width: 100%;
        height: auto;
    }
}

.click-effect {
    position: absolute;
    width: 60px;
    height: 60px;
    border: 3px solid #ff6b6b;
    border-radius: 50%;
    pointer-events: none;
    animation: clickRipple 0.6s ease-out forwards;
    z-index: 20;
    transform: translate(-50%, -50%);
}

@keyframes clickRipple {
    0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 1;
    }
    100% {
        transform: translate(-50%, -50%) scale(2);
        opacity: 0;
    }
}

.hidden-object {
    z-index: 10;
    user-select: none;
}

.scene-tree, .scene-cloud, .scene-building {
    pointer-events: none;
    user-select: none;
}






</style>
</head>
<body>
    <div class="header">
        <!-- <div class="logo1">🎮</div> --><div class="logo"> BitBlitz Games</div> 
        <div class="nav-buttons">
            <button class="nav-btn" onclick="showHome()">Home</button>
            <button class="nav-btn" onclick="showAbout()">About</button>
        </div>
    </div>

    <div class="container">
        <div id="home-screen">
            <div class="welcome-section">
                <div class="welcome-title">Welcome to BitBlitz</div>
                <div class="welcome-subtitle">Play amazing games instantly - no downloads required!</div>
            </div>

            <div class="game-grid">
    <div class="game-card" onclick="openGame('snake')">
        <div class="game-icon">🐍</div>
        <div class="game-title">Snake Game</div>
        <div class="game-description">Classic snake game! Eat food, grow longer, and avoid hitting yourself. Use arrow keys to control your snake and beat your high score!</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('memory')">
        <div class="game-icon">🧠</div>
        <div class="game-title">Memory Match</div>
        <div class="game-description">Test your memory! Flip cards to find matching pairs. Complete all pairs to win the game. Can you do it in minimum moves?</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('quiz')">
        <div class="game-icon">🤔</div>
        <div class="game-title">Quick Quiz</div>
        <div class="game-description">Challenge your knowledge with fun trivia questions covering various topics. How many can you get right?</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('typing')">
        <div class="game-icon">⌨️</div>
        <div class="game-title">Speed Typing</div>
        <div class="game-description">Test your typing speed and accuracy. Type the given text as fast and accurately as possible!</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('reaction')">
        <div class="game-icon">⚡</div>
        <div class="game-title">Reaction Test</div>
        <div class="game-description">Test your reflexes! Click as soon as the circle turns green. How fast are your reactions?</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('pong')">
        <div class="game-icon">🏓</div>
        <div class="game-title">Pong Classic</div>
        <div class="game-description">Classic Pong game! Use your paddle to hit the ball and score points against the AI opponent.</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('simple')">
        <div class="game-icon">🎯</div>
        <div class="game-title">Click Game</div>
        <div class="game-description">Simple clicking game to test your reflexes. Click the targets as they appear!</div>
        <button class="play-btn">Play Now</button>
    </div>
    <div class="game-card" onclick="openGame('mathblaster')">
        <div class="game-icon">🔢</div>
        <div class="game-title">Math Blaster</div>
        <div class="game-description">Quick mental math challenges! Solve problems as fast as you can. Perfect for sharpening your arithmetic skills.</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('aimtrainer')">
        <div class="game-icon">🎯</div>
        <div class="game-title">Aim Trainer</div>
        <div class="game-description">Test and improve your clicking accuracy! Hit targets as they appear to boost your reflexes.</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('colormatch')">
        <div class="game-icon">🌈</div>
        <div class="game-title">Color Match</div>
        <div class="game-description">Click the color of the text, not what it says! A challenging cognitive test that's surprisingly addictive.</div>
        <button class="play-btn">Play Now</button>
    </div>
    <div class="game-card" onclick="openGame('wordscramble')">
        <div class="game-icon">🔤</div>
        <div class="game-title">Word Scramble</div>
        <div class="game-description">Unscramble the letters to find the hidden word! Test your vocabulary across different categories.</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('game2048')">
        <div class="game-icon">🎲</div>
        <div class="game-title">2048 Clone</div>
        <div class="game-description">Slide numbered tiles to combine them and reach 2048! A highly addictive puzzle game.</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('flappybird')">
        <div class="game-icon">🐦</div>
        <div class="game-title">Flappy Bird</div>
        <div class="game-description">Navigate through pipes by clicking or pressing space. How far can you fly?</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('asteroids')">
        <div class="game-icon">🌟</div>
        <div class="game-title">Asteroids Mini</div>
        <div class="game-description">Navigate your spaceship through an asteroid field! Shoot asteroids and survive as long as possible in this classic arcade-style game.</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('pixelart')">
        <div class="game-icon">🎨</div>
        <div class="game-title">Pixel Art Creator</div>
        <div class="game-description">Create beautiful pixel art with our drawing tools! Choose colors, use different brushes, and save your masterpieces.</div>
        <button class="play-btn">Play Now</button>
    </div>

    <div class="game-card" onclick="openGame('hiddenobject')">
    <div class="game-icon">🔍</div>
    <div class="game-title">Hidden Object</div>
    <div class="game-description">Find hidden objects in beautiful scenes! Use your observation skills to locate all items before time runs out.</div>
    <button class="play-btn">Play Now</button>
</div>

<div class="game-card" onclick="openGame('towerdefense')">
    <div class="game-icon">🌙</div>
    <div class="game-title">Tower Defense</div>
    <div class="game-description">Build towers to defend against waves of enemies! Strategically place different tower types to protect your base.</div>
    <button class="play-btn">Play Now</button>
</div>






</div>


        </div>
    </div>

    <!-- Game Screens -->
    <div id="snake-screen" class="game-screen">
        <div class="game-container">
            <button class="close-btn" onclick="closeGame()">&times;</button>
            <div class="score-board">
                <div>Snake Game</div>
                <div>Score: <span id="snake-score">0</span></div>
            </div>
            <div class="game-area">
                <canvas id="snake-canvas" width="400" height="400"></canvas>
                <div class="game-controls">Use arrow keys to control your snake</div>
            </div>
        </div>
    </div>

    <div id="memory-screen" class="game-screen">
        <div class="game-container">
            <button class="close-btn" onclick="closeGame()">&times;</button>
            <div class="score-board">
                <div>Memory Match</div>
                <div>Moves: <span id="memory-moves">0</span></div>
            </div>
            <div class="game-area">
                <div id="memory-grid" class="memory-grid"></div>
                <div class="game-controls">Click cards to find matching pairs</div>
            </div>
        </div>
    </div>

    <div id="simple-screen" class="game-screen">
        <div class="game-container">
            <button class="close-btn" onclick="closeGame()">&times;</button>
            <div class="score-board">
                <div>Click Game</div>
                <div>Score: <span id="simple-score">0</span></div>
            </div>
            <div class="game-area">
                <div id="click-target" style="width: 60px; height: 60px; background: #ff6b6b; border-radius: 50%; cursor: pointer; margin: 2rem auto;"></div>
                <div class="game-controls">Click the circle as fast as you can!</div>
            </div>
        </div>
    </div>

    <!-- Quiz Game Screen -->
    <div id="quiz-screen" class="game-screen">
        <div class="game-container">
            <button class="close-btn" onclick="closeGame()">&times;</button>
            <div class="score-board">
                <div>Quick Quiz</div>
                <div>Score: <span id="quiz-score">0</span>/<span id="quiz-total">0</span></div>
            </div>
            <div class="game-area">
                <div id="quiz-setup" class="quiz-setup">
                    <h2 style="margin-bottom: 2rem; color: #ffd93d;">Choose Your Quiz Category</h2>
                    <div class="category-selection">
                        <button class="category-btn" onclick="selectCategory('general')">🌍 General Knowledge</button>
                        <button class="category-btn" onclick="selectCategory('science')">🔬 Science</button>
                        <button class="category-btn" onclick="selectCategory('history')">📚 History</button>
                        <button class="category-btn" onclick="selectCategory('sports')">⚽ Sports</button>
                    </div>
                    <button class="start-quiz-btn" onclick="startQuiz()" style="display: none;">Start Quiz</button>
                </div>
                <div id="quiz-content" style="display: none;"></div>
            </div>
        </div>
    </div>

    <!-- Typing Game Screen -->
    <div id="typing-screen" class="game-screen">
        <div class="game-container">
            <button class="close-btn" onclick="closeGame()">&times;</button>
            <div class="score-board">
                <div>Speed Typing</div>
                <div>WPM: <span id="typing-wpm-display">0</span></div>
            </div>
            <div class="game-area">
                <div class="typing-area">
                    <div id="typing-text" class="typing-text"></div>
                    <input type="text" id="typing-input" class="typing-input" placeholder="Start typing when ready...">
                    <div class="typing-stats">
                        <div class="stat">
                            <div class="stat-value" id="typing-wpm">0</div>
                            <div>WPM</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="accuracy">100%</div>
                            <div>Accuracy</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="chars-typed">0</div>
                            <div>Characters</div>
                        </div>
                    </div>
                    <button class="typing-reset-btn" onclick="initTyping()">Reset Text</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Reaction Test Screen -->
    <div id="reaction-screen" class="game-screen">
        <div class="game-container">
            <button class="close-btn" onclick="closeGame()">&times;</button>
            <div class="score-board">
                <div>Reaction Test</div>
                <div>Best: <span id="reaction-best">-</span>ms</div>
            </div>
            <div class="game-area">
                <div class="reaction-game">
                    <div id="reaction-circle" class="reaction-circle waiting">
                        Click when GREEN!
                    </div>
                    <div id="reaction-result"></div>
                    <button onclick="startReactionTest()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">Start Test</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Pong Game Screen -->
    <div id="pong-screen" class="game-screen">
        <div class="game-container">
            <button class="close-btn" onclick="closeGame()">&times;</button>
            <div class="score-board">
                <div>Pong Classic</div>
                <div>You: <span id="pong-player-score">0</span> | AI: <span id="pong-ai-score">0</span></div>
            </div>
            <div class="game-area">
                <canvas id="pong-canvas" width="600" height="400"></canvas>
                <div class="game-controls">Move mouse to control your paddle</div>
            </div>
        </div>
    </div>

    <!-- Math Blaster Game Screen -->
<div id="mathblaster-screen" class="game-screen">
    <div class="game-container">
        <button class="close-btn" onclick="closeGame()">&times;</button>
        <div class="score-board">
            <div>Math Blaster</div>
            <div>Score: <span id="math-score">0</span> | Level: <span id="math-level">1</span></div>
        </div>
        <div class="game-area">
            <div class="math-game">
                <div id="math-question" class="math-question">Get Ready!</div>
                <div id="math-options" class="math-options"></div>
                <div class="math-stats">
                    <div class="stat">
                        <div class="stat-value" id="math-streak">0</div>
                        <div>Streak</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="math-time">30</div>
                        <div>Time</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="math-accuracy">100%</div>
                        <div>Accuracy</div>
                    </div>
                </div>
                <button id="math-start-btn" class="start-game-btn" onclick="startMathGame()">Start Game</button>
            </div>
        </div>
    </div>
</div>


<!-- Aim Trainer Game Screen -->
<div id="aimtrainer-screen" class="game-screen">
    <div class="game-container">
        <button class="close-btn" onclick="closeGame()">&times;</button>
        <div class="score-board">
            <div>Aim Trainer</div>
            <div>Score: <span id="aim-score">0</span> | Accuracy: <span id="aim-accuracy">0%</span></div>
        </div>
        <div class="game-area">
            <div class="aim-game">
                <div id="aim-playground" class="aim-playground">
                    <div id="aim-crosshair" class="crosshair">+</div>
                </div>
                <div class="aim-stats">
                    <div class="stat">
                        <div class="stat-value" id="aim-hits">0</div>
                        <div>Hits</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="aim-misses">0</div>
                        <div>Misses</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="aim-avg-time">0ms</div>
                        <div>Avg Time</div>
                    </div>
                </div>
                <button id="aim-start-btn" class="start-game-btn" onclick="startAimGame()">Start Training</button>
            </div>
        </div>
    </div>
</div>


<!-- Color Match Game Screen -->
<div id="colormatch-screen" class="game-screen">
    <div class="game-container">
        <button class="close-btn" onclick="closeGame()">&times;</button>
        <div class="score-board">
            <div>Color Match</div>
            <div>Score: <span id="color-score">0</span> | Lives: <span id="color-lives">3</span></div>
        </div>
        <div class="game-area">
            <div class="color-game">
                <div id="color-instruction" class="color-instruction">
                    Click the color of the TEXT, not what it says!
                </div>
                <div id="color-display" class="color-display">
                    <div id="color-word" class="color-word">Ready?</div>
                </div>
                <div id="color-options" class="color-options"></div>
                <div class="color-stats">
                    <div class="stat">
                        <div class="stat-value" id="color-streak">0</div>
                        <div>Streak</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="color-speed">0s</div>
                        <div>Avg Speed</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="color-level">1</div>
                        <div>Level</div>
                    </div>
                </div>
                <button id="color-start-btn" class="start-game-btn" onclick="startColorGame()">Start Challenge</button>
            </div>
        </div>
    </div>
</div>

<!-- Word Scramble Game Screen -->
<div id="wordscramble-screen" class="game-screen">
    <div class="game-container">
        <button class="close-btn" onclick="closeGame()">&times;</button>
        <div class="score-board">
            <div>Word Scramble</div>
            <div>Score: <span id="word-score">0</span> | Level: <span id="word-level">1</span></div>
        </div>
        <div class="game-area">
            <div class="word-game">
                <div id="word-category" class="word-category">Animals</div>
                <div id="scrambled-word" class="scrambled-word">READY?</div>
                <div class="word-input-section">
                    <input type="text" id="word-input" class="word-input" placeholder="Type your answer here..." maxlength="20">
                    <button id="word-submit" class="word-submit-btn" onclick="checkWordAnswer()">Submit</button>
                </div>
                <div id="word-hint" class="word-hint" style="display: none;">
                    <span id="hint-text">Click for hint</span>
                    <button class="hint-btn" onclick="showHint()">💡 Hint</button>
                </div>
                <div class="word-stats">
                    <div class="stat">
                        <div class="stat-value" id="words-solved">0</div>
                        <div>Solved</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="word-streak">0</div>
                        <div>Streak</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="hints-used">0</div>
                        <div>Hints</div>
                    </div>
                </div>
                <button id="word-start-btn" class="start-game-btn" onclick="startWordGame()">Start Game</button>
                <button id="word-skip-btn" class="skip-btn" onclick="skipWord()" style="display: none;">Skip Word</button>
            </div>
        </div>
    </div>
</div>


<!-- 2048 Game Screen -->
<div id="game2048-screen" class="game-screen">
    <div class="game-container">
        <button class="close-btn" onclick="closeGame()">&times;</button>
        <div class="score-board">
            <div>2048 Game</div>
            <div>Score: <span id="game2048-score">0</span> | Best: <span id="game2048-best">0</span></div>
        </div>
        <div class="game-area">
            <div class="game2048">
                <div class="game2048-instructions">
                    Use arrow keys or swipe to move tiles. Combine tiles with the same number to reach 2048!
                </div>
                <div id="game2048-grid" class="game2048-grid">
                    <!-- Grid will be generated by JavaScript -->
                </div>
                <div class="game2048-controls">
                    <button class="game2048-btn" onclick="newGame2048()">New Game</button>
                    <button class="game2048-btn" onclick="undoMove2048()" id="undo-btn">Undo</button>
                </div>
                <div id="game2048-status" class="game2048-status"></div>
            </div>
        </div>
    </div>
</div>
<!-- Flappy Bird Game Screen -->
<div id="flappybird-screen" class="game-screen">
    <div class="game-container">
        <button class="close-btn" onclick="closeGame()">&times;</button>
        <div class="score-board">
            <div>Flappy Bird</div>
            <div>Score: <span id="flappy-score">0</span> | Best: <span id="flappy-best">0</span></div>
        </div>
        <div class="game-area">
            <div class="flappy-game">
                <canvas id="flappy-canvas" width="400" height="600"></canvas>
                <div class="flappy-instructions" id="flappy-instructions">
                    Click or press SPACE to fly!
                    <br>
                    <button class="start-game-btn" onclick="startFlappyGame()">Start Game</button>
                </div>
                <div class="flappy-controls">
                    <div class="control-hint">🖱️ Click anywhere or press SPACE to flap</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Asteroids Mini Game Screen -->
<div id="asteroids-screen" class="game-screen">
    <div class="game-container">
        <button class="close-btn" onclick="closeGame()">&times;</button>
        <div class="score-board">
            <div>Asteroids Mini</div>
            <div>Score: <span id="asteroids-score">0</span> | Lives: <span id="asteroids-lives">3</span></div>
        </div>
        <div class="game-area">
            <div class="asteroids-game">
                <canvas id="asteroids-canvas" width="600" height="500"></canvas>
                <div class="asteroids-instructions" id="asteroids-instructions">
                    <div class="control-instructions">
                        <div>🚀 <strong>WASD</strong> or <strong>Arrow Keys</strong> - Move Ship</div>
                        <div>🔫 <strong>SPACE</strong> - Shoot</div>
                        <div>⚡ <strong>SHIFT</strong> - Thrust Boost</div>
                    </div>
                    <button class="start-game-btn" onclick="startAsteroidsGame()">Launch Ship</button>
                </div>
                <div class="asteroids-stats">
                    <div class="stat">
                        <div class="stat-value" id="asteroids-level">1</div>
                        <div>Wave</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="asteroids-destroyed">0</div>
                        <div>Destroyed</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="asteroids-accuracy">100%</div>
                        <div>Accuracy</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Pixel Art Creator Game Screen -->
<div id="pixelart-screen" class="game-screen">
    <div class="game-container">
        <button class="close-btn" onclick="closeGame()">&times;</button>
        <div class="score-board">
            <div>Pixel Art Creator</div>
            <div>Grid: <span id="pixel-grid-size">16x16</span> | Tool: <span id="current-tool">Brush</span></div>
        </div>
        <div class="game-area">
            <div class="pixel-art-game">
                <div class="pixel-art-container">
                    <div class="pixel-toolbar">
                        <div class="tool-section">
                            <h4>🛠️ Tools</h4>
                            <div class="tool-buttons">
                                <button class="tool-btn active" data-tool="brush" onclick="selectTool('brush')">🖌️ Brush</button>
                                <button class="tool-btn" data-tool="eraser" onclick="selectTool('eraser')">🧽 Eraser</button>
                                <button class="tool-btn" data-tool="fill" onclick="selectTool('fill')">🪣 Fill</button>
                                <button class="tool-btn" data-tool="picker" onclick="selectTool('picker')">🎯 Picker</button>
                            </div>
                        </div>
                        
                        <div class="color-section">
                            <h4>🎨 Colors</h4>
                            <div class="color-palette" id="color-palette">
                                <!-- Colors will be generated by JavaScript -->
                            </div>
                            <div class="color-inputs">
                                <input type="color" id="custom-color" class="custom-color-input" onchange="addCustomColor(this.value)">
                                <label for="custom-color">Custom</label>
                            </div>
                        </div>
                        
                        <div class="grid-section">
                            <h4>📐 Grid Size</h4>
                            <div class="grid-buttons">
                                <button class="grid-btn" onclick="changeGridSize(8)">8x8</button>
                                <button class="grid-btn active" onclick="changeGridSize(16)">16x16</button>
                                <button class="grid-btn" onclick="changeGridSize(32)">32x32</button>
                            </div>
                        </div>
                        
                        <div class="action-section">
                            <h4>💾 Actions</h4>
                            <div class="action-buttons">
                                <button class="action-btn" onclick="clearCanvas()">🗑️ Clear</button>
                                <button class="action-btn" onclick="downloadArt()">💾 Save</button>
                                <button class="action-btn" onclick="loadTemplate()">📂 Template</button>
                                <button class="action-btn" onclick="showGrid = !showGrid; drawPixelGrid()">📏 Grid</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="canvas-container">
                        <canvas id="pixel-canvas" width="512" height="512"></canvas>
                        <div class="canvas-info">
                            <div>Position: <span id="mouse-pos">0, 0</span></div>
                            <div>Color: <span id="current-color-display">#000000</span></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Hidden Object Game Screen -->
<div id="hiddenobject-screen" class="game-screen">
    <div class="game-container">
        <button class="close-btn" onclick="closeGame()">&times;</button>
        <div class="score-board">
            <div>Hidden Object</div>
            <div>Score: <span id="hidden-score">0</span> | Time: <span id="hidden-time">180</span>s</div>
        </div>
        <div class="game-area">
            <div class="hidden-object-game">
                <div class="hidden-scene-container">
                    <div id="hidden-scene" class="hidden-scene">
                        <!-- Objects will be generated by JavaScript -->
                    </div>
                    <div class="zoom-controls">
                        <button class="zoom-btn" onclick="zoomScene(1.2)">🔍 Zoom In</button>
                        <button class="zoom-btn" onclick="zoomScene(0.8)">🔍 Zoom Out</button>
                        <button class="zoom-btn" onclick="resetZoom()">📐 Reset</button>
                    </div>
                </div>
                
                <div class="hidden-sidebar">
                    <div class="objects-to-find">
                        <h3>🎯 Find These Objects:</h3>
                        <div id="object-list" class="object-list">
                            <!-- Object list will be generated -->
                        </div>
                    </div>
                    
                    <div class="game-progress">
                        <div class="progress-bar">
                            <div id="progress-fill" class="progress-fill"></div>
                        </div>
                        <div class="progress-text">
                            <span id="found-count">0</span> / <span id="total-count">10</span> Found
                        </div>
                    </div>
                    
                    <div class="hidden-stats">
                        <div class="stat">
                            <div class="stat-value" id="hidden-level">1</div>
                            <div>Level</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="objects-found">0</div>
                            <div>Found</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="accuracy-percent">100%</div>
                            <div>Accuracy</div>
                        </div>
                    </div>
                    
                    <div class="hidden-controls">
                        <button class="hint-btn" onclick="useHint()" id="hint-btn">
                            💡 Hint (<span id="hints-left">3</span>)
                        </button>
                        <button class="start-game-btn" onclick="startHiddenGame()" id="start-hidden-btn">Start Game</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<!-- Tower Defense Game Screen -->
<div id="towerdefense-screen" class="game-screen">
    <div class="game-container">
        <button class="close-btn" onclick="closeGame()">&times;</button>
        <div class="score-board">
            <div>Tower Defense</div>
            <div>Gold: <span id="td-gold">100</span> | Lives: <span id="td-lives">20</span> | Wave: <span id="td-wave">1</span></div>
        </div>
        <div class="game-area">
            <div class="tower-defense-game">
                <div class="td-game-area">
                    <canvas id="td-canvas" width="600" height="500"></canvas>
                    <div class="wave-info" id="wave-info">
                        <div class="wave-status">Prepare for Wave 1!</div>
                        <button class="start-wave-btn" onclick="startWave()" id="start-wave-btn">Start Wave</button>
                    </div>
                </div>
                
                <div class="td-sidebar">
                    <div class="tower-shop">
                        <h3>🏗️ Build Towers</h3>
                        <div class="tower-buttons">
                            <div class="tower-btn" onclick="selectTower('basic')" data-tower="basic">
                                <div class="tower-icon">🗼</div>
                                <div class="tower-name">Basic Tower</div>
                                <div class="tower-cost">💰 25</div>
                                <div class="tower-stats">Damage: 20</div>
                            </div>
                            
                            <div class="tower-btn" onclick="selectTower('cannon')" data-tower="cannon">
                                <div class="tower-icon">🔫</div>
                                <div class="tower-name">Cannon</div>
                                <div class="tower-cost">💰 50</div>
                                <div class="tower-stats">AOE Damage</div>
                            </div>
                            
                            <div class="tower-btn" onclick="selectTower('ice')" data-tower="ice">
                                <div class="tower-icon">❄️</div>
                                <div class="tower-name">Ice Tower</div>
                                <div class="tower-cost">💰 40</div>
                                <div class="tower-stats">Slows Enemies</div>
                            </div>
                            
                            <div class="tower-btn" onclick="selectTower('lightning')" data-tower="lightning">
                                <div class="tower-icon">⚡</div>
                                <div class="tower-name">Lightning</div>
                                <div class="tower-cost">💰 80</div>
                                <div class="tower-stats">Chain Attack</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="selected-tower-info" id="selected-tower-info" style="display: none;">
                        <h3>🔧 Tower Info</h3>
                        <div id="tower-details"></div>
                        <div class="tower-actions">
                            <button class="upgrade-btn" onclick="upgradeTower()">⬆️ Upgrade</button>
                            <button class="sell-btn" onclick="sellTower()">💰 Sell</button>
                        </div>
                    </div>
                    
                    <div class="wave-progress">
                        <h3>📊 Wave Progress</h3>
                        <div class="enemy-progress">
                            <div class="progress-bar">
                                <div id="wave-progress-fill" class="progress-fill"></div>
                            </div>
                            <div class="progress-text">
                                <span id="enemies-remaining">0</span> enemies remaining
                            </div>
                        </div>
                    </div>
                    
                    <div class="td-stats">
                        <div class="stat">
                            <div class="stat-value" id="enemies-killed">0</div>
                            <div>Killed</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="towers-built">0</div>
                            <div>Towers</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>









    <script>
        // Global game state
        let currentGame = null;
        let gameStates = {};

        // Home navigation
        function showHome() {
            document.getElementById('home-screen').style.display = 'block';
        }

        function showAbout() {
            alert('BitBlitz Games - A collection of fun mini-games you can play instantly in your browser. No downloads, no sign-ups, just pure gaming fun!');
        }

        // Game management
        function openGame(gameType) {
            currentGame = gameType;
            document.getElementById('home-screen').style.display = 'none';
            document.getElementById(gameType + '-screen').style.display = 'block';
            
            switch(gameType) {
                case 'snake': initSnake(); break;
                case 'memory': initMemory(); break;
                case 'simple': initSimple(); break;
            }
        }

        function closeGame() {
            if (currentGame) {
                document.getElementById(currentGame + '-screen').style.display = 'none';
                if (gameStates[currentGame] && gameStates[currentGame].cleanup) {
                    gameStates[currentGame].cleanup();
                }
            }
            document.getElementById('home-screen').style.display = 'block';
            currentGame = null;
        }

        // Snake Game
        function initSnake() {
            const canvas = document.getElementById('snake-canvas');
            const ctx = canvas.getContext('2d');
            const gridSize = 20;
            const tileCount = canvas.width / gridSize;

            let snake = [{x: 10, y: 10}];
            let food = {x: 15, y: 15};
            let dx = 0, dy = 0;
            let score = 0;
            let gameLoop;

            function drawGame() {
                // Clear canvas with gradient
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#0f0f23');
                gradient.addColorStop(1, '#1a1a3e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw grid
                ctx.strokeStyle = 'rgba(78, 205, 196, 0.1)';
                ctx.lineWidth = 1;
                for (let i = 0; i < tileCount; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * gridSize, 0);
                    ctx.lineTo(i * gridSize, canvas.height);
                    ctx.moveTo(0, i * gridSize);
                    ctx.lineTo(canvas.width, i * gridSize);
                    ctx.stroke();
                }

                // Draw snake with gradient
                snake.forEach((segment, index) => {
                    const gradient = ctx.createRadialGradient(
                        segment.x * gridSize + gridSize/2, segment.y * gridSize + gridSize/2, 0,
                        segment.x * gridSize + gridSize/2, segment.y * gridSize + gridSize/2, gridSize/2
                    );
                    
                    if (index === 0) {
                        // Snake head
                        gradient.addColorStop(0, '#4ecdc4');
                        gradient.addColorStop(1, '#2ba8a0');
                    } else {
                        // Snake body
                        gradient.addColorStop(0, '#45b7d1');
                        gradient.addColorStop(1, '#2980b9');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(segment.x * gridSize + 1, segment.y * gridSize + 1, gridSize - 2, gridSize - 2);
                    
                    // Add eyes to head
                    if (index === 0) {
                        ctx.fillStyle = 'white';
                        ctx.fillRect(segment.x * gridSize + 4, segment.y * gridSize + 4, 3, 3);
                        ctx.fillRect(segment.x * gridSize + 13, segment.y * gridSize + 4, 3, 3);
                    }
                });

                // Draw food with pulsing effect
                const time = Date.now() * 0.005;
                const pulse = Math.sin(time) * 0.3 + 1;
                const foodGradient = ctx.createRadialGradient(
                    food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2, 0,
                    food.x * gridSize + gridSize/2, food.y * gridSize + gridSize/2, gridSize/2 * pulse
                );
                foodGradient.addColorStop(0, '#ff6b6b');
                foodGradient.addColorStop(1, '#e55555');
                
                ctx.fillStyle = foodGradient;
                ctx.fillRect(food.x * gridSize + 1, food.y * gridSize + 1, gridSize - 2, gridSize - 2);
            }


            function update() {
                const head = {x: snake[0].x + dx, y: snake[0].y + dy};

                // Check wall collision
                if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                    resetSnake();
                    return;
                }

                // Check self collision
                if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    resetSnake();
                    return;
                }

                snake.unshift(head);

                // Check food collision
                if (head.x === food.x && head.y === food.y) {
                    score += 10;
                    document.getElementById('snake-score').textContent = score;
                    generateFood();
                } else {
                    snake.pop();
                }

                drawGame();
            }

            function generateFood() {
                food = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
            }

            function resetSnake() {
                snake = [{x: 10, y: 10}];
                dx = 0; dy = 0;
                score = 0;
                document.getElementById('snake-score').textContent = score;
                generateFood();
            }

            // Key controls
            function handleKeyPress(e) {
                if (currentGame !== 'snake') return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        if (dy !== 1) { dx = 0; dy = -1; }
                        break;
                    case 'ArrowDown':
                        if (dy !== -1) { dx = 0; dy = 1; }
                        break;
                    case 'ArrowLeft':
                        if (dx !== 1) { dx = -1; dy = 0; }
                        break;
                    case 'ArrowRight':
                        if (dx !== -1) { dx = 1; dy = 0; }
                        break;
                }
            }

            document.addEventListener('keydown', handleKeyPress);

            // Start game loop
            gameLoop = setInterval(update, 150);
            
            // Store cleanup function
            gameStates['snake'] = {
                cleanup: () => {
                    clearInterval(gameLoop);
                    document.removeEventListener('keydown', handleKeyPress);
                }
            };

            drawGame();
        }

        // Memory Game
        function initMemory() {
            const emojis = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼'];
            const gameEmojis = [...emojis, ...emojis];
            gameEmojis.sort(() => Math.random() - 0.5);

            let flippedCards = [];
            let matchedPairs = 0;
            let moves = 0;

            const grid = document.getElementById('memory-grid');
            grid.innerHTML = '';

            gameEmojis.forEach((emoji, index) => {
                const card = document.createElement('div');
                card.className = 'memory-card';
                card.dataset.emoji = emoji;
                card.dataset.index = index;
                card.addEventListener('click', flipCard);
                grid.appendChild(card);
            });

            function flipCard() {
                if (flippedCards.length === 2) return;
                if (this.classList.contains('flipped') || this.classList.contains('matched')) return;

                this.classList.add('flipped');
                this.textContent = this.dataset.emoji;
                flippedCards.push(this);

                if (flippedCards.length === 2) {
                    moves++;
                    document.getElementById('memory-moves').textContent = moves;
                    
                    setTimeout(() => {
                        if (flippedCards[0].dataset.emoji === flippedCards[1].dataset.emoji) {
                            flippedCards.forEach(card => card.classList.add('matched'));
                            matchedPairs++;
                            
                            if (matchedPairs === emojis.length) {
                                setTimeout(() => alert('Congratulations! You won!'), 500);
                            }
                        } else {
                            flippedCards.forEach(card => {
                                card.classList.remove('flipped');
                                card.textContent = '';
                            });
                        }
                        flippedCards = [];
                    }, 1000);
                }
            }
        }

        // Simple Click Game
        function initSimple() {
            let score = 0;
            const target = document.getElementById('click-target');
            let gameActive = true;
            let targetSpeed = 2000; // milliseconds
            
            // Enhanced target styling
            target.style.cssText = `
                width: 80px;
                height: 80px;
                background: linear-gradient(45deg, #ff6b6b, #ff8e53);
                border-radius: 50%;
                cursor: pointer;
                margin: 2rem auto;
                position: relative;
                transition: all 0.3s ease;
                box-shadow: 0 10px 20px rgba(255, 107, 107, 0.4);
                border: 4px solid rgba(255, 255, 255, 0.3);
            `;
            
            function createRipple(e) {
                const ripple = document.createElement('div');
                const rect = target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                ripple.style.cssText = `
                    position: absolute;
                    width: 20px;
                    height: 20px;
                    background: rgba(255, 255, 255, 0.6);
                    border-radius: 50%;
                    transform: translate(-50%, -50%);
                    left: ${x}px;
                    top: ${y}px;
                    animation: rippleEffect 0.6s ease-out forwards;
                    pointer-events: none;
                `;
                
                target.appendChild(ripple);
                setTimeout(() => ripple.remove(), 600);
            }
            
            // Add ripple animation CSS
            const style = document.createElement('style');
            style.textContent = `
                @keyframes rippleEffect {
                    to {
                        width: 100px;
                        height: 100px;
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
            
            target.addEventListener('click', (e) => {
                if (!gameActive) return;
                
                score++;
                document.getElementById('simple-score').textContent = score;
                
                // Create ripple effect
                createRipple(e);
                
                // Increase speed every 5 points
                if (score % 5 === 0) {
                    targetSpeed = Math.max(500, targetSpeed - 200);
                }
                
                // Move target
                moveTarget();
            });
            
            function moveTarget() {
                const container = target.parentElement;
                const maxX = container.offsetWidth - 100;
                const maxY = container.offsetHeight - 100;
                
                const x = Math.random() * maxX;
                const y = Math.random() * maxY;
                
                target.style.position = 'absolute';
                target.style.left = x + 'px';
                target.style.top = y + 'px';
                
                // Change color
                const colors = [
                    'linear-gradient(45deg, #ff6b6b, #ff8e53)',
                    'linear-gradient(45deg, #4ecdc4, #44a08d)',
                    'linear-gradient(45deg, #45b7d1, #96c93d)',
                    'linear-gradient(45deg, #f9ca24, #f0932b)',
                    'linear-gradient(45deg, #eb4d4b, #6c5ce7)',
                    'linear-gradient(45deg, #a55eea, #26de81)'
                ];
                target.style.background = colors[Math.floor(Math.random() * colors.length)];
                
                // Auto-move target if not clicked
                setTimeout(() => {
                    if (gameActive) moveTarget();
                }, targetSpeed);
            }
            
            // Start the game
            moveTarget();
            
            gameStates['simple'] = {
                cleanup: () => {
                    gameActive = false;
                }
            };
        }


        // Quiz variables
        let selectedCategory = null;
        let currentQuizQuestions = [];
        let currentQuestionIndex = 0;
        let quizScore = 0;

        // Quiz questions database
        const quizQuestions = {
            general: [
                {
                    question: "What is the capital of France?",
                    options: ["London", "Berlin", "Paris", "Madrid"],
                    correct: 2
                },
                {
                    question: "Which planet is known as the Red Planet?",
                    options: ["Venus", "Mars", "Jupiter", "Saturn"],
                    correct: 1
                },
                {
                    question: "What is the largest mammal in the world?",
                    options: ["African Elephant", "Blue Whale", "Giraffe", "Polar Bear"],
                    correct: 1
                }
            ],
            science: [
                {
                    question: "What is the chemical symbol for gold?",
                    options: ["Go", "Gd", "Au", "Ag"],
                    correct: 2
                },
                {
                    question: "How many bones are in the human body?",
                    options: ["196", "206", "216", "226"],
                    correct: 1
                }
            ],
            history: [
                {
                    question: "In which year did World War II end?",
                    options: ["1944", "1945", "1946", "1947"],
                    correct: 1
                },
                {
                    question: "Who was the first person to walk on the moon?",
                    options: ["Buzz Aldrin", "Neil Armstrong", "John Glenn", "Alan Shepard"],
                    correct: 1
                }
            ],
            sports: [
                {
                    question: "How many players are on a basketball team on the court?",
                    options: ["4", "5", "6", "7"],
                    correct: 1
                },
                {
                    question: "In which sport would you perform a slam dunk?",
                    options: ["Tennis", "Basketball", "Volleyball", "Soccer"],
                    correct: 1
                }
            ]
        };

        function selectCategory(category) {
            selectedCategory = category;
            document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
            document.querySelector('.start-quiz-btn').style.display = 'block';
        }

        function startQuiz() {
            if (!selectedCategory) return;
            
            currentQuizQuestions = [...quizQuestions[selectedCategory]];
            currentQuestionIndex = 0;
            quizScore = 0;
            
            document.getElementById('quiz-setup').style.display = 'none';
            document.getElementById('quiz-content').style.display = 'block';
            document.getElementById('quiz-total').textContent = currentQuizQuestions.length;
            
            showQuestion();
        }

        function showQuestion() {
            const question = currentQuizQuestions[currentQuestionIndex];
            const content = document.getElementById('quiz-content');
            
            content.innerHTML = `
                <div class="quiz-question">
                    <h3>${question.question}</h3>
                </div>
                <div class="quiz-options">
                    ${question.options.map((option, index) => 
                        `<button class="quiz-option" onclick="answerQuestion(${index})">${option}</button>`
                    ).join('')}
                </div>
            `;
        }

        function answerQuestion(selectedIndex) {
            const question = currentQuizQuestions[currentQuestionIndex];
            const options = document.querySelectorAll('.quiz-option');
            
            options[selectedIndex].classList.add(selectedIndex === question.correct ? 'correct' : 'wrong');
            if (selectedIndex !== question.correct) {
                options[question.correct].classList.add('correct');
            }
            
            if (selectedIndex === question.correct) {
                quizScore++;
                document.getElementById('quiz-score').textContent = quizScore;
            }
            
            setTimeout(() => {
                currentQuestionIndex++;
                if (currentQuestionIndex < currentQuizQuestions.length) {
                    showQuestion();
                } else {
                    endQuiz();
                }
            }, 1500);
        }

        function endQuiz() {
            const content = document.getElementById('quiz-content');
            const percentage = Math.round((quizScore / currentQuizQuestions.length) * 100);
            
            content.innerHTML = `
                <div style="text-align: center;">
                    <h2>Quiz Complete!</h2>
                    <p>Your Score: ${quizScore}/${currentQuizQuestions.length} (${percentage}%)</p>
                    <button onclick="initQuiz()" style="margin-top: 2rem; padding: 1rem 2rem; background: #667eea; color: white; border: none; border-radius: 10px; cursor: pointer;">Play Again</button>
                </div>
            `;
        }

        function initQuiz() {
            selectedCategory = null;
            document.getElementById('quiz-setup').style.display = 'block';
            document.getElementById('quiz-content').style.display = 'none';
            document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelector('.start-quiz-btn').style.display = 'none';
            document.getElementById('quiz-score').textContent = '0';
        }

        // Typing Game
        function initTyping() {
            const texts = [
                "The quick brown fox jumps over the lazy dog. This sentence contains all letters of the alphabet.",
                "Programming is the art of thinking through problems and expressing solutions in code.",
                "Practice makes perfect. The more you type, the faster and more accurate you become.",
                "Technology is advancing rapidly, changing the way we work, learn, and communicate with each other."
            ];
            
            const randomText = texts[Math.floor(Math.random() * texts.length)];
            const textElement = document.getElementById('typing-text');
            const input = document.getElementById('typing-input');
            
            textElement.innerHTML = randomText.split('').map(char => `<span>${char}</span>`).join('');
            input.value = '';
            input.focus();
            
            let startTime = null;
            let currentIndex = 0;
            let errors = 0;
            
            function updateDisplay() {
                const spans = textElement.querySelectorAll('span');
                const typed = input.value;
                
                spans.forEach((span, index) => {
                    span.className = '';
                    if (index < typed.length) {
                        if (typed[index] === span.textContent) {
                            span.classList.add('correct');
                        } else {
                            span.classList.add('incorrect');
                            if (index === typed.length - 1) errors++;
                        }
                    } else if (index === typed.length) {
                        span.classList.add('current');
                    }
                });
                
                // Calculate WPM and accuracy
                const timeElapsed = startTime ? (Date.now() - startTime) / 1000 / 60 : 0;
                const wordsTyped = typed.length / 5;
                const wpm = timeElapsed > 0 ? Math.round(wordsTyped / timeElapsed) : 0;
                const accuracy = typed.length > 0 ? Math.round(((typed.length - errors) / typed.length) * 100) : 100;
                
                document.getElementById('typing-wpm').textContent = wpm;
                document.getElementById('typing-wpm-display').textContent = wpm;
                document.getElementById('accuracy').textContent = accuracy + '%';
                document.getElementById('chars-typed').textContent = typed.length;
            }
            
            input.addEventListener('input', () => {
                if (!startTime) startTime = Date.now();
                updateDisplay();
                
                if (input.value === randomText) {
                    setTimeout(() => alert('Congratulations! You completed the text!'), 100);
                }
            });
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Backspace') {
                    errors = Math.max(0, errors - 1);
                }
            });
            
            updateDisplay();
        }

        // Reaction Test
        function initReaction() {
            let bestTime = localStorage.getItem('reactionBest') || null;
            if (bestTime) {
                document.getElementById('reaction-best').textContent = bestTime;
            }
        }

        function startReactionTest() {
            const circle = document.getElementById('reaction-circle');
            const result = document.getElementById('reaction-result');
            
            circle.className = 'reaction-circle waiting';
            circle.textContent = 'Wait for GREEN...';
            result.textContent = '';
            
            const delay = Math.random() * 3000 + 2000; // 2-5 seconds
            
            setTimeout(() => {
                const startTime = Date.now();
                circle.className = 'reaction-circle ready';
                circle.textContent = 'CLICK NOW!';
                
                function handleClick() {
                    const reactionTime = Date.now() - startTime;
                    circle.className = 'reaction-circle clicked';
                    circle.textContent = 'Good job!';
                    
                    result.textContent = `Your reaction time: ${reactionTime}ms`;
                    
                    const bestTime = localStorage.getItem('reactionBest');
                    if (!bestTime || reactionTime < parseInt(bestTime)) {
                        localStorage.setItem('reactionBest', reactionTime);
                        document.getElementById('reaction-best').textContent = reactionTime;
                        result.textContent += ' - NEW BEST!';
                    }
                    
                    circle.removeEventListener('click', handleClick);
                }
                
                circle.addEventListener('click', handleClick);
            }, delay);
        }

        // Pong Game
        function initPong() {
            const canvas = document.getElementById('pong-canvas');
            const ctx = canvas.getContext('2d');
            
            const paddleHeight = 100;
            const paddleWidth = 10;
            const ballSize = 10;
            
            let playerScore = 0;
            let aiScore = 0;
            
            const player = {
                x: 10,
                y: canvas.height / 2 - paddleHeight / 2,
                width: paddleWidth,
                height: paddleHeight,
                color: 'white'
            };
            
            const ai = {
                x: canvas.width - paddleWidth - 10,
                y: canvas.height / 2 - paddleHeight / 2,
                width: paddleWidth,
                height: paddleHeight,
                color: 'white'
            };
            
            const ball = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                dx: 5,
                dy: 3,
                width: ballSize,
                height: ballSize,
                color: 'white'
            };
            
            function drawRect(obj) {
                ctx.fillStyle = obj.color;
                ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
            }
            
            function update() {
                // Clear canvas
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Move ball
                ball.x += ball.dx;
                ball.y += ball.dy;
                
                // Ball collision with top/bottom
                if (ball.y <= 0 || ball.y + ball.height >= canvas.height) {
                    ball.dy = -ball.dy;
                }
                
                // Ball collision with paddles
                if (ball.x <= player.x + player.width && 
                    ball.y + ball.height >= player.y && 
                    ball.y <= player.y + player.height) {
                    ball.dx = -ball.dx;
                }
                
                if (ball.x + ball.width >= ai.x && 
                    ball.y + ball.height >= ai.y && 
                    ball.y <= ai.y + ai.height) {
                    ball.dx = -ball.dx;
                }
                
                // Score
                if (ball.x < 0) {
                    aiScore++;
                    document.getElementById('pong-ai-score').textContent = aiScore;
                    resetBall();
                }
                
                if (ball.x > canvas.width) {
                    playerScore++;
                    document.getElementById('pong-player-score').textContent = playerScore;
                    resetBall();
                }
                
                // AI movement
                const aiCenter = ai.y + ai.height / 2;
                const ballCenter = ball.y + ball.height / 2;
                
                if (aiCenter < ballCenter - 35) {
                    ai.y += 4;
                } else if (aiCenter > ballCenter + 35) {
                    ai.y -= 4;
                }
                
                // Keep AI paddle in bounds
                if (ai.y < 0) ai.y = 0;
                if (ai.y + ai.height > canvas.height) ai.y = canvas.height - ai.height;
                
                // Draw everything
                drawRect(player);
                drawRect(ai);
                drawRect(ball);
                
                // Draw center line
                ctx.setLineDash([5, 15]);
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 0);
                ctx.lineTo(canvas.width / 2, canvas.height);
                ctx.strokeStyle = 'white';
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            function resetBall() {
                ball.x = canvas.width / 2;
                ball.y = canvas.height / 2;
                ball.dx = -ball.dx;
                ball.dy = Math.random() * 6 - 3;
            }
            
            // Mouse control for player paddle
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseY = e.clientY - rect.top;
                player.y = mouseY - player.height / 2;
                
                // Keep player paddle in bounds
                if (player.y < 0) player.y = 0;
                if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
            });
            
            // Start game loop
            const gameLoop = setInterval(update, 1000 / 60);
            
            // Store cleanup function
            gameStates['pong'] = {
                cleanup: () => {
                    clearInterval(gameLoop);
                }
            };
        }

        // Update the openGame function to include new games
        function openGame(gameType) {
            currentGame = gameType;
            document.getElementById('home-screen').style.display = 'none';
            document.getElementById(gameType + '-screen').style.display = 'block';
            
            switch(gameType) {
                case 'snake': initSnake(); break;
                case 'memory': initMemory(); break;
                case 'simple': initSimple(); break;
                case 'quiz': initQuiz(); break;
                case 'typing': initTyping(); break;
                case 'reaction': initReaction(); break;
                case 'pong': initPong(); break;
            }
        }

        // Create floating particles background
        function createParticles() {
            const particles = document.createElement('div');
            particles.className = 'particles';
            document.body.appendChild(particles);

            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 3 + 3) + 's';
                particles.appendChild(particle);
            }
        }

        // Initialize particles when page loads
        window.addEventListener('load', createParticles);

        // Math Blaster Game
let mathGameState = {
    score: 0,
    level: 1,
    streak: 0,
    timeLeft: 30,
    totalQuestions: 0,
    correctAnswers: 0,
    currentAnswer: 0,
    gameActive: false,
    timer: null
};

function initMathBlaster() {
    // Reset game state
    mathGameState = {
        score: 0,
        level: 1,
        streak: 0,
        timeLeft: 30,
        totalQuestions: 0,
        correctAnswers: 0,
        currentAnswer: 0,
        gameActive: false,
        timer: null
    };
    
    updateMathDisplay();
    document.getElementById('math-question').textContent = 'Get Ready!';
    document.getElementById('math-options').innerHTML = '';
    document.getElementById('math-start-btn').style.display = 'block';
}

function startMathGame() {
    mathGameState.gameActive = true;
    mathGameState.timeLeft = 30;
    document.getElementById('math-start-btn').style.display = 'none';
    
    // Start timer
    mathGameState.timer = setInterval(() => {
        mathGameState.timeLeft--;
        document.getElementById('math-time').textContent = mathGameState.timeLeft;
        
        if (mathGameState.timeLeft <= 0) {
            endMathGame();
        }
    }, 1000);
    
    generateMathQuestion();
}

function generateMathQuestion() {
    if (!mathGameState.gameActive) return;
    
    const operations = ['+', '-', '*'];
    const operation = operations[Math.floor(Math.random() * operations.length)];
    
    let num1, num2, question;
    
    // Adjust difficulty based on level
    const maxNum = Math.min(10 + mathGameState.level * 5, 50);
    
    switch (operation) {
        case '+':
            num1 = Math.floor(Math.random() * maxNum) + 1;
            num2 = Math.floor(Math.random() * maxNum) + 1;
            mathGameState.currentAnswer = num1 + num2;
            question = `${num1} + ${num2}`;
            break;
        case '-':
            num1 = Math.floor(Math.random() * maxNum) + 10;
            num2 = Math.floor(Math.random() * (num1 - 1)) + 1;
            mathGameState.currentAnswer = num1 - num2;
            question = `${num1} - ${num2}`;
            break;
        case '*':
            num1 = Math.floor(Math.random() * Math.min(12, mathGameState.level + 3)) + 1;
            num2 = Math.floor(Math.random() * Math.min(12, mathGameState.level + 3)) + 1;
            mathGameState.currentAnswer = num1 * num2;
            question = `${num1} × ${num2}`;
            break;
    }
    
    document.getElementById('math-question').textContent = question;
    generateMathOptions();
}

function generateMathOptions() {
    const options = [mathGameState.currentAnswer];
    
    // Generate 3 wrong answers
    while (options.length < 4) {
        const offset = Math.floor(Math.random() * 20) - 10;
        const wrongAnswer = mathGameState.currentAnswer + offset;
        
        if (wrongAnswer !== mathGameState.currentAnswer && !options.includes(wrongAnswer) && wrongAnswer > 0) {
            options.push(wrongAnswer);
        }
    }
    
    // Shuffle options
    for (let i = options.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [options[i], options[j]] = [options[j], options[i]];
    }
    
    // Display options
    const optionsContainer = document.getElementById('math-options');
    optionsContainer.innerHTML = '';
    
    options.forEach(option => {
        const button = document.createElement('button');
        button.className = 'math-option';
        button.textContent = option;
        button.addEventListener('click', () => checkMathAnswer(option));
        optionsContainer.appendChild(button);
    });
}

function checkMathAnswer(selectedAnswer) {
    if (!mathGameState.gameActive) return;
    
    mathGameState.totalQuestions++;
    const isCorrect = selectedAnswer === mathGameState.currentAnswer;
    
    // Visual feedback
    const buttons = document.querySelectorAll('.math-option');
    buttons.forEach(btn => {
        if (parseInt(btn.textContent) === selectedAnswer) {
            btn.classList.add(isCorrect ? 'correct' : 'wrong');
        }
        if (parseInt(btn.textContent) === mathGameState.currentAnswer && !isCorrect) {
            btn.classList.add('correct');
        }
    });
    
    if (isCorrect) {
        mathGameState.score += mathGameState.level * 10;
        mathGameState.streak++;
        mathGameState.correctAnswers++;
        
        // Level up every 10 correct answers
        if (mathGameState.correctAnswers % 10 === 0) {
            mathGameState.level++;
        }
    } else {
        mathGameState.streak = 0;
    }
    
    updateMathDisplay();
    
    setTimeout(() => {
        if (mathGameState.gameActive) {
            generateMathQuestion();
        }
    }, 1000);
}

function updateMathDisplay() {
    document.getElementById('math-score').textContent = mathGameState.score;
    document.getElementById('math-level').textContent = mathGameState.level;
    document.getElementById('math-streak').textContent = mathGameState.streak;
    document.getElementById('math-time').textContent = mathGameState.timeLeft;
    
    const accuracy = mathGameState.totalQuestions > 0 ? 
        Math.round((mathGameState.correctAnswers / mathGameState.totalQuestions) * 100) : 100;
    document.getElementById('math-accuracy').textContent = accuracy + '%';
}

function endMathGame() {
    mathGameState.gameActive = false;
    if (mathGameState.timer) {
        clearInterval(mathGameState.timer);
    }
    
    document.getElementById('math-question').textContent = 
        `Game Over! Final Score: ${mathGameState.score}`;
    document.getElementById('math-options').innerHTML = '';
    document.getElementById('math-start-btn').style.display = 'block';
    document.getElementById('math-start-btn').textContent = 'Play Again';
}

// Aim Trainer Game
let aimGameState = {
    score: 0,
    hits: 0,
    misses: 0,
    gameActive: false,
    currentTarget: null,
    targetStartTime: 0,
    reactionTimes: [],
    gameTimer: null,
    targetTimer: null
};

function initAimTrainer() {
    aimGameState = {
        score: 0,
        hits: 0,
        misses: 0,
        gameActive: false,
        currentTarget: null,
        targetStartTime: 0,
        reactionTimes: [],
        gameTimer: null,
        targetTimer: null
    };
    
    updateAimDisplay();
    document.getElementById('aim-start-btn').style.display = 'block';
    
    // Mouse tracking for crosshair
    const playground = document.getElementById('aim-playground');
    const crosshair = document.getElementById('aim-crosshair');
    
    playground.addEventListener('mousemove', (e) => {
        const rect = playground.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        crosshair.style.left = x + 'px';
        crosshair.style.top = y + 'px';
    });
    
    // Handle misses
    playground.addEventListener('click', (e) => {
        if (!aimGameState.gameActive) return;
        
        if (!e.target.classList.contains('aim-target')) {
            aimGameState.misses++;
            updateAimDisplay();
            
            // Show miss effect
            const missEffect = document.createElement('div');
            missEffect.className = 'miss-effect';
            missEffect.textContent = 'MISS!';
            missEffect.style.left = (e.clientX - e.currentTarget.getBoundingClientRect().left) + 'px';
            missEffect.style.top = (e.clientY - e.currentTarget.getBoundingClientRect().top) + 'px';
            playground.appendChild(missEffect);
            
            setTimeout(() => missEffect.remove(), 600);
        }
    });
}

function startAimGame() {
    aimGameState.gameActive = true;
    document.getElementById('aim-start-btn').style.display = 'none';
    
    // Game duration: 60 seconds
    aimGameState.gameTimer = setTimeout(() => {
        endAimGame();
    }, 60000);
    
    spawnTarget();
}

function spawnTarget() {
    if (!aimGameState.gameActive) return;
    
    // Remove existing target
    if (aimGameState.currentTarget) {
        aimGameState.currentTarget.remove();
    }
    
    const playground = document.getElementById('aim-playground');
    const target = document.createElement('div');
    target.className = 'aim-target';
    
    // Random position
    const maxX = playground.offsetWidth - 60;
    const maxY = playground.offsetHeight - 60;
    const x = Math.random() * maxX;
    const y = Math.random() * maxY;
    
    target.style.left = x + 'px';
    target.style.top = y + 'px';
    
    // Random size (difficulty)
    const size = 40 + Math.random() * 40; // 40-80px
    target.style.width = size + 'px';
    target.style.height = size + 'px';
    
    aimGameState.targetStartTime = Date.now();
    aimGameState.currentTarget = target;
    
    target.addEventListener('click', (e) => {
        e.stopPropagation();
        hitTarget(target);
    });
    
    playground.appendChild(target);
    
    // Auto-remove target after 2-4 seconds
    aimGameState.targetTimer = setTimeout(() => {
        if (target.parentNode) {
            target.remove();
            aimGameState.misses++;
            updateAimDisplay();
            
            if (aimGameState.gameActive) {
                setTimeout(spawnTarget, 200);
            }
        }
    }, 2000 + Math.random() * 2000);
}

function hitTarget(target) {
    const reactionTime = Date.now() - aimGameState.targetStartTime;
    aimGameState.reactionTimes.push(reactionTime);
    aimGameState.hits++;
    aimGameState.score += Math.max(100 - Math.floor(reactionTime / 10), 10);
    
    updateAimDisplay();
    
    // Show hit effect
    const hitEffect = document.createElement('div');
    hitEffect.className = 'hit-effect';
    hitEffect.textContent = '+' + Math.max(100 - Math.floor(reactionTime / 10), 10);
    hitEffect.style.left = target.style.left;
    hitEffect.style.top = target.style.top;
    target.parentNode.appendChild(hitEffect);
    
    setTimeout(() => hitEffect.remove(), 800);
    
    // Remove target and spawn new one
    if (aimGameState.targetTimer) {
        clearTimeout(aimGameState.targetTimer);
    }
    target.remove();
    
    if (aimGameState.gameActive) {
        setTimeout(spawnTarget, 300 + Math.random() * 700);
    }
}

function updateAimDisplay() {
    document.getElementById('aim-score').textContent = aimGameState.score;
    document.getElementById('aim-hits').textContent = aimGameState.hits;
    document.getElementById('aim-misses').textContent = aimGameState.misses;
    
    const total = aimGameState.hits + aimGameState.misses;
    const accuracy = total > 0 ? Math.round((aimGameState.hits / total) * 100) : 0;
    document.getElementById('aim-accuracy').textContent = accuracy + '%';
    
    const avgTime = aimGameState.reactionTimes.length > 0 ?
        Math.round(aimGameState.reactionTimes.reduce((a, b) => a + b) / aimGameState.reactionTimes.length) : 0;
    document.getElementById('aim-avg-time').textContent = avgTime + 'ms';
}

function endAimGame() {
    aimGameState.gameActive = false;
    
    if (aimGameState.gameTimer) clearTimeout(aimGameState.gameTimer);
    if (aimGameState.targetTimer) clearTimeout(aimGameState.targetTimer);
    if (aimGameState.currentTarget) aimGameState.currentTarget.remove();
    
    document.getElementById('aim-start-btn').style.display = 'block';
    document.getElementById('aim-start-btn').textContent = 'Train Again';
    
    alert(`Training Complete!\nScore: ${aimGameState.score}\nAccuracy: ${Math.round((aimGameState.hits / (aimGameState.hits + aimGameState.misses)) * 100)}%`);
}

// Color Match Game
let colorGameState = {
    score: 0,
    lives: 3,
    streak: 0,
    level: 1,
    gameActive: false,
    currentColor: '',
    currentWord: '',
    startTime: 0,
    reactionTimes: []
};

const colorData = {
    red: '#ff6b6b',
    blue: '#4ecdc4',
    green: '#4caf50',
    yellow: '#ffd93d',
    purple: '#a55eea',
    orange: '#ff8e53',
    pink: '#ff6b9d',
    cyan: '#17a2b8'
};

function initColorMatch() {
    colorGameState = {
        score: 0,
        lives: 3,
        streak: 0,
        level: 1,
        gameActive: false,
        currentColor: '',
        currentWord: '',
        startTime: 0,
        reactionTimes: []
    };
    
    updateColorDisplay();
    document.getElementById('color-word').textContent = 'Ready?';
    document.getElementById('color-options').innerHTML = '';
    document.getElementById('color-start-btn').style.display = 'block';
}

function startColorGame() {
    colorGameState.gameActive = true;
    colorGameState.lives = 3;
    document.getElementById('color-start-btn').style.display = 'none';
    generateColorChallenge();
}

function generateColorChallenge() {
    if (!colorGameState.gameActive) return;
    
    const colors = Object.keys(colorData);
    const words = [...colors];
    
    // Pick random word and color (intentionally different for challenge)
    colorGameState.currentWord = words[Math.floor(Math.random() * words.length)];
    colorGameState.currentColor = colors[Math.floor(Math.random() * colors.length)];
    
    // Sometimes make them the same for easier questions at low levels
    if (Math.random() < (0.3 - colorGameState.level * 0.05)) {
        colorGameState.currentColor = colorGameState.currentWord;
    }
    
    // Display word in different color
    const wordElement = document.getElementById('color-word');
    wordElement.textContent = colorGameState.currentWord.toUpperCase();
    wordElement.style.color = colorData[colorGameState.currentColor];
    
    generateColorOptions();
    colorGameState.startTime = Date.now();
}

function generateColorOptions() {
    const optionsContainer = document.getElementById('color-options');
    optionsContainer.innerHTML = '';
    
    const colors = Object.keys(colorData);
    const shuffledColors = colors.sort(() => Math.random() - 0.5).slice(0, 4);
    
    // Ensure correct answer is included
    if (!shuffledColors.includes(colorGameState.currentColor)) {
        shuffledColors[Math.floor(Math.random() * 4)] = colorGameState.currentColor;
    }
    
    shuffledColors.forEach(color => {
        const option = document.createElement('div');
        option.className = 'color-option';
        option.style.background = colorData[color];
        option.addEventListener('click', () => checkColorAnswer(color));
        optionsContainer.appendChild(option);
    });
}

function checkColorAnswer(selectedColor) {
    if (!colorGameState.gameActive) return;
    
    const reactionTime = Date.now() - colorGameState.startTime;
    colorGameState.reactionTimes.push(reactionTime);
    
    const isCorrect = selectedColor === colorGameState.currentColor;
    
    // Visual feedback
    const options = document.querySelectorAll('.color-option');
    options.forEach(option => {
        const optionColor = Object.keys(colorData).find(key => 
            colorData[key] === option.style.background || 
            colorData[key] === getComputedStyle(option).backgroundColor
        );
        
        if (optionColor === selectedColor) {
            option.classList.add(isCorrect ? 'correct' : 'wrong');
        }
    });
    
    if (isCorrect) {
        colorGameState.score += Math.max(100 - Math.floor(reactionTime / 50), 25);
        colorGameState.streak++;
        
        // Level up every 15 correct answers
        if (colorGameState.streak % 15 === 0) {
            colorGameState.level++;
        }
    } else {
        colorGameState.lives--;
        colorGameState.streak = 0;
        
        if (colorGameState.lives <= 0) {
            endColorGame();
            return;
        }
    }
    
    updateColorDisplay();
    
    setTimeout(() => {
        if (colorGameState.gameActive) {
            generateColorChallenge();
        }
    }, 1200);
}

function updateColorDisplay() {
    document.getElementById('color-score').textContent = colorGameState.score;
    document.getElementById('color-lives').textContent = colorGameState.lives;
    document.getElementById('color-streak').textContent = colorGameState.streak;
    document.getElementById('color-level').textContent = colorGameState.level;
    
    const avgSpeed = colorGameState.reactionTimes.length > 0 ?
        (colorGameState.reactionTimes.reduce((a, b) => a + b) / colorGameState.reactionTimes.length / 1000).toFixed(1) : 0;
    document.getElementById('color-speed').textContent = avgSpeed + 's';
}

function endColorGame() {
    colorGameState.gameActive = false;
    
    document.getElementById('color-word').textContent = `Game Over! Score: ${colorGameState.score}`;
    document.getElementById('color-options').innerHTML = '';
    document.getElementById('color-start-btn').style.display = 'block';
    document.getElementById('color-start-btn').textContent = 'Challenge Again';
}

// Update the openGame function to include new games
function openGame(gameType) {
    currentGame = gameType;
    document.getElementById('home-screen').style.display = 'none';
    document.getElementById(gameType + '-screen').style.display = 'block';
    
    switch(gameType) {
        case 'snake': initSnake(); break;
        case 'memory': initMemory(); break;
        case 'simple': initSimple(); break;
        case 'quiz': initQuiz(); break;
        case 'typing': initTyping(); break;
        case 'reaction': initReaction(); break;
        case 'pong': initPong(); break;
        case 'mathblaster': initMathBlaster(); break;
        case 'aimtrainer': initAimTrainer(); break;
        case 'colormatch': initColorMatch(); break;
    }
}
gameStates['mathblaster'] = {
    cleanup: () => {
        if (mathGameState.timer) clearInterval(mathGameState.timer);
        mathGameState.gameActive = false;
    }
};

gameStates['aimtrainer'] = {
    cleanup: () => {
        if (aimGameState.gameTimer) clearTimeout(aimGameState.gameTimer);
        if (aimGameState.targetTimer) clearTimeout(aimGameState.targetTimer);
        if (aimGameState.currentTarget) aimGameState.currentTarget.remove();
        aimGameState.gameActive = false;
    }
};

gameStates['colormatch'] = {
    cleanup: () => {
        colorGameState.gameActive = false;
    }
};


// Word Scramble Game
let wordGameState = {
    score: 0,
    level: 1,
    wordsSolved: 0,
    streak: 0,
    hintsUsed: 0,
    gameActive: false,
    currentWord: '',
    currentScrambled: '',
    currentHint: '',
    currentCategory: 'animals'
};

const wordDatabase = {
    animals: [
        {word: 'ELEPHANT', hint: 'Large mammal with trunk'},
        {word: 'GIRAFFE', hint: 'Tallest animal on Earth'},
        {word: 'DOLPHIN', hint: 'Intelligent marine mammal'},
        {word: 'BUTTERFLY', hint: 'Colorful flying insect'},
        {word: 'PENGUIN', hint: 'Black and white flightless bird'},
        {word: 'KANGAROO', hint: 'Jumping marsupial from Australia'},
        {word: 'OCTOPUS', hint: 'Eight-armed sea creature'},
        {word: 'CHEETAH', hint: 'Fastest land animal'},
        {word: 'RHINOCEROS', hint: 'Large horned mammal'},
        {word: 'FLAMINGO', hint: 'Pink wading bird'}
    ],
    countries: [
        {word: 'AUSTRALIA', hint: 'Island continent'},
        {word: 'BRAZIL', hint: 'Largest South American country'},
        {word: 'CANADA', hint: 'Northern North American country'},
        {word: 'EGYPT', hint: 'Home of the pyramids'},
        {word: 'FRANCE', hint: 'Country of the Eiffel Tower'},
        {word: 'GERMANY', hint: 'European country, capital Berlin'},
        {word: 'INDIA', hint: 'Country of the Taj Mahal'},
        {word: 'JAPAN', hint: 'Land of the rising sun'},
        {word: 'MEXICO', hint: 'North American country, speaks Spanish'},
        {word: 'RUSSIA', hint: 'Largest country in the world'}
    ],
    technology: [
        {word: 'COMPUTER', hint: 'Electronic calculating machine'},
        {word: 'INTERNET', hint: 'Global network of networks'},
        {word: 'SMARTPHONE', hint: 'Handheld communication device'},
        {word: 'ALGORITHM', hint: 'Set of rules for problem solving'},
        {word: 'DATABASE', hint: 'Organized collection of data'},
        {word: 'PROGRAMMING', hint: 'Writing computer instructions'},
        {word: 'ARTIFICIAL', hint: 'Not natural, man-made'},
        {word: 'ROBOTICS', hint: 'Science of building robots'},
        {word: 'CYBERSECURITY', hint: 'Protection from digital attacks'},
        {word: 'BLOCKCHAIN', hint: 'Distributed ledger technology'}
    ]
};

function initWordScramble() {
    wordGameState = {
        score: 0,
        level: 1,
        wordsSolved: 0,
        streak: 0,
        hintsUsed: 0,
        gameActive: false,
        currentWord: '',
        currentScrambled: '',
        currentHint: '',
        currentCategory: 'animals'
    };
    
    updateWordDisplay();
    document.getElementById('word-start-btn').style.display = 'block';
    document.getElementById('word-skip-btn').style.display = 'none';
    document.getElementById('word-hint').style.display = 'none';
    document.getElementById('word-input').value = '';
}

function startWordGame() {
    wordGameState.gameActive = true;
    document.getElementById('word-start-btn').style.display = 'none';
    document.getElementById('word-skip-btn').style.display = 'block';
    document.getElementById('word-hint').style.display = 'block';
    generateNewWord();
}

function generateNewWord() {
    if (!wordGameState.gameActive) return;
    
    // Change category every 10 words
    const categories = Object.keys(wordDatabase);
    const categoryIndex = Math.floor(wordGameState.wordsSolved / 10) % categories.length;
    wordGameState.currentCategory = categories[categoryIndex];
    
    const categoryWords = wordDatabase[wordGameState.currentCategory];
    const randomWord = categoryWords[Math.floor(Math.random() * categoryWords.length)];
    
    wordGameState.currentWord = randomWord.word;
    wordGameState.currentHint = randomWord.hint;
    wordGameState.currentScrambled = scrambleWord(randomWord.word);
    
    document.getElementById('word-category').textContent = wordGameState.currentCategory.toUpperCase();
    document.getElementById('scrambled-word').textContent = wordGameState.currentScrambled;
    document.getElementById('hint-text').textContent = 'Click for hint';
    document.getElementById('word-input').value = '';
    document.getElementById('word-input').focus();
}

function scrambleWord(word) {
    const letters = word.split('');
    for (let i = letters.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [letters[i], letters[j]] = [letters[j], letters[i]];
    }
    return letters.join('');
}

function checkWordAnswer() {
    const userAnswer = document.getElementById('word-input').value.toUpperCase().trim();
    
    if (!userAnswer) return;
    
    const scrambledElement = document.getElementById('scrambled-word');
    
    if (userAnswer === wordGameState.currentWord) {
        // Correct answer
        wordGameState.score += (10 - wordGameState.hintsUsed) * wordGameState.level;
        wordGameState.wordsSolved++;
        wordGameState.streak++;
        
        if (wordGameState.wordsSolved % 5 === 0) {
            wordGameState.level++;
        }
        
        scrambledElement.classList.add('word-correct');
        scrambledElement.textContent = 'CORRECT!';
        
        setTimeout(() => {
            scrambledElement.classList.remove('word-correct');
            generateNewWord();
        }, 1500);
        
    } else {
        // Wrong answer
        wordGameState.streak = 0;
        scrambledElement.classList.add('word-wrong');
        
        setTimeout(() => {
            scrambledElement.classList.remove('word-wrong');
        }, 600);
    }
    
    updateWordDisplay();
}

function showHint() {
    document.getElementById('hint-text').textContent = wordGameState.currentHint;
    wordGameState.hintsUsed++;
    updateWordDisplay();
}

function skipWord() {
    wordGameState.streak = 0;
    generateNewWord();
}

function updateWordDisplay() {
    document.getElementById('word-score').textContent = wordGameState.score;
    document.getElementById('word-level').textContent = wordGameState.level;
    document.getElementById('words-solved').textContent = wordGameState.wordsSolved;
    document.getElementById('word-streak').textContent = wordGameState.streak;
    document.getElementById('hints-used').textContent = wordGameState.hintsUsed;
}

// Add Enter key support for word input
document.addEventListener('DOMContentLoaded', function() {
    const wordInput = document.getElementById('word-input');
    if (wordInput) {
        wordInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                checkWordAnswer();
            }
        });
    }
});

// 2048 Game
let game2048State = {
    grid: [],
    score: 0,
    bestScore: localStorage.getItem('2048-best') || 0,
    gameWon: false,
    gameOver: false,
    previousState: null
};

function initGame2048() {
    game2048State = {
        grid: [],
        score: 0,
        bestScore: localStorage.getItem('2048-best') || 0,
        gameWon: false,
        gameOver: false,
        previousState: null
    };
    
    document.getElementById('game2048-best').textContent = game2048State.bestScore;
    newGame2048();
}

function newGame2048() {
    game2048State.grid = Array(4).fill().map(() => Array(4).fill(0));
    game2048State.score = 0;
    game2048State.gameWon = false;
    game2048State.gameOver = false;
    
    addRandomTile();
    addRandomTile();
    updateDisplay2048();
    
    // Add keyboard controls
    document.addEventListener('keydown', handle2048KeyPress);
}

function addRandomTile() {
    const emptyCells = [];
    for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
            if (game2048State.grid[i][j] === 0) {
                emptyCells.push({row: i, col: j});
            }
        }
    }
    
    if (emptyCells.length > 0) {
        const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
        game2048State.grid[randomCell.row][randomCell.col] = Math.random() < 0.9 ? 2 : 4;
    }
}

function updateDisplay2048() {
    const gridElement = document.getElementById('game2048-grid');
    gridElement.innerHTML = '';
    
    for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
            const cell = document.createElement('div');
            cell.className = 'game2048-cell';
            
            const value = game2048State.grid[i][j];
            if (value > 0) {
                cell.textContent = value;
                cell.classList.add(`tile-${value}`);
                
                if (value >= 2048 && !game2048State.gameWon) {
                    game2048State.gameWon = true;
                    setTimeout(() => {
                        document.getElementById('game2048-status').textContent = '🎉 You reached 2048! Keep playing for higher scores!';
                    }, 300);
                }
            }
            
            gridElement.appendChild(cell);
        }
    }
    
    document.getElementById('game2048-score').textContent = game2048State.score;
    
    if (game2048State.score > game2048State.bestScore) {
        game2048State.bestScore = game2048State.score;
        localStorage.setItem('2048-best', game2048State.bestScore);
        document.getElementById('game2048-best').textContent = game2048State.bestScore;
    }
    
    if (isGameOver2048()) {
        game2048State.gameOver = true;
        document.getElementById('game2048-status').textContent = '😢 Game Over! No more moves possible.';
    }
}

function handle2048KeyPress(e) {
    if (game2048State.gameOver) return;
    
    let moved = false;
    game2048State.previousState = {
        grid: game2048State.grid.map(row => [...row]),
        score: game2048State.score
    };
    
    switch(e.key) {
        case 'ArrowUp':
            e.preventDefault();
            moved = moveUp();
            break;
        case 'ArrowDown':
            e.preventDefault();
            moved = moveDown();
            break;
        case 'ArrowLeft':
            e.preventDefault();
            moved = moveLeft();
            break;
        case 'ArrowRight':
            e.preventDefault();
            moved = moveRight();
            break;
    }
    
    if (moved) {
        addRandomTile();
        updateDisplay2048();
    }
}

function moveLeft() {
    let moved = false;
    for (let i = 0; i < 4; i++) {
        const row = game2048State.grid[i].filter(val => val !== 0);
        
        for (let j = 0; j < row.length - 1; j++) {
            if (row[j] === row[j + 1]) {
                row[j] *= 2;
                game2048State.score += row[j];
                row.splice(j + 1, 1);
            }
        }
        
        while (row.length < 4) {
            row.push(0);
        }
        
        for (let j = 0; j < 4; j++) {
            if (game2048State.grid[i][j] !== row[j]) {
                moved = true;
            }
            game2048State.grid[i][j] = row[j];
        }
    }
    return moved;
}

function moveRight() {
    let moved = false;
    for (let i = 0; i < 4; i++) {
        const row = game2048State.grid[i].filter(val => val !== 0);
        
        for (let j = row.length - 1; j > 0; j--) {
            if (row[j] === row[j - 1]) {
                row[j] *= 2;
                game2048State.score += row[j];
                row.splice(j - 1, 1);
                j--;
            }
        }
        
        while (row.length < 4) {
            row.unshift(0);
        }
        
        for (let j = 0; j < 4; j++) {
            if (game2048State.grid[i][j] !== row[j]) {
                moved = true;
            }
            game2048State.grid[i][j] = row[j];
        }
    }
    return moved;
}

function moveUp() {
    let moved = false;
    for (let j = 0; j < 4; j++) {
        const column = [];
        for (let i = 0; i < 4; i++) {
            if (game2048State.grid[i][j] !== 0) {
                column.push(game2048State.grid[i][j]);
            }
        }
        
        for (let i = 0; i < column.length - 1; i++) {
            if (column[i] === column[i + 1]) {
                column[i] *= 2;
                game2048State.score += column[i];
                column.splice(i + 1, 1);
            }
        }
        
        while (column.length < 4) {
            column.push(0);
        }
        
        for (let i = 0; i < 4; i++) {
            if (game2048State.grid[i][j] !== column[i]) {
                moved = true;
            }
            game2048State.grid[i][j] = column[i];
        }
    }
    return moved;
}

function moveDown() {
    let moved = false;
    for (let j = 0; j < 4; j++) {
        const column = [];
        for (let i = 0; i < 4; i++) {
            if (game2048State.grid[i][j] !== 0) {
                column.push(game2048State.grid[i][j]);
            }
        }
        
        for (let i = column.length - 1; i > 0; i--) {
            if (column[i] === column[i - 1]) {
                column[i] *= 2;
                game2048State.score += column[i];
                column.splice(i - 1, 1);
                i--;
            }
        }
        
        while (column.length < 4) {
            column.unshift(0);
        }
        
        for (let i = 0; i < 4; i++) {
            if (game2048State.grid[i][j] !== column[i]) {
                moved = true;
            }
            game2048State.grid[i][j] = column[i];
        }
    }
    return moved;
}

function isGameOver2048() {
    // Check for empty cells
    for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
            if (game2048State.grid[i][j] === 0) return false;
        }
    }
    
    // Check for possible merges
    for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
            if (j < 3 && game2048State.grid[i][j] === game2048State.grid[i][j + 1]) return false;
            if (i < 3 && game2048State.grid[i][j] === game2048State.grid[i + 1][j]) return false;
        }
    }
    
    return true;
}

function undoMove2048() {
    if (game2048State.previousState) {
        game2048State.grid = game2048State.previousState.grid.map(row => [...row]);
        game2048State.score = game2048State.previousState.score;
        game2048State.gameOver = false;
        updateDisplay2048();
        document.getElementById('game2048-status').textContent = '';
    }
}

// Flappy Bird Game
// Flappy Bird Game - CORRECTED VERSION

// Flappy Bird Game - COMPLETELY FIXED VERSION
let flappyGameState = {
    bird: { x: 50, y: 300, velocity: 0, size: 20 },
    pipes: [],
    score: 0,
    bestScore: localStorage.getItem('flappy-best') || 0,
    gameActive: false,
    gameStarted: false,
    canvas: null,
    ctx: null,
    gameLoop: null
};

const GRAVITY = 0.5;
const JUMP_FORCE = -10;
const PIPE_WIDTH = 60;
const PIPE_GAP = 130;
const PIPE_SPEED = 2;

function initFlappyBird() {
    flappyGameState.canvas = document.getElementById('flappy-canvas');
    flappyGameState.ctx = flappyGameState.canvas.getContext('2d');
    
    // Set canvas size explicitly
    flappyGameState.canvas.width = 400;
    flappyGameState.canvas.height = 600;
    
    // Reset game state
    flappyGameState.bird = { x: 80, y: 300, velocity: 0, size: 20 };
    flappyGameState.pipes = [];
    flappyGameState.score = 0;
    flappyGameState.gameActive = false;
    flappyGameState.gameStarted = false;
    flappyGameState.bestScore = localStorage.getItem('flappy-best') || 0;
    
    document.getElementById('flappy-best').textContent = flappyGameState.bestScore;
    document.getElementById('flappy-score').textContent = '0';
    document.getElementById('flappy-instructions').style.display = 'block';
    
    // Remove any existing game over screens
    const existingGameOver = document.querySelector('.game-over-screen');
    if (existingGameOver) existingGameOver.remove();
    
    // Clear canvas and draw initial state
    drawInitialState();
    
    // Setup event listeners
    setupFlappyEvents();
}

function setupFlappyEvents() {
    // Remove existing listeners
    flappyGameState.canvas.onclick = null;
    
    // Add click listener
    flappyGameState.canvas.addEventListener('click', flap);
    
    // Keyboard listener
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && currentGame === 'flappybird') {
            e.preventDefault();
            flap();
        }
    });
}

function drawInitialState() {
    const ctx = flappyGameState.ctx;
    const canvas = flappyGameState.canvas;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw sky gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(0.7, '#98D8E8');
    gradient.addColorStop(1, '#87CEEB');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw clouds
    drawClouds(ctx);
    
    // Draw ground
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
    
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0, canvas.height - 50, canvas.width, 20);
    
    // Draw bird
    drawBird(ctx);
}

function drawClouds(ctx) {
    const clouds = [
        {x: 50, y: 80, size: 25},
        {x: 120, y: 60, size: 35},
        {x: 180, y: 90, size: 20},
        {x: 250, y: 70, size: 30},
        {x: 320, y: 100, size: 25}
    ];
    
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    
    clouds.forEach(cloud => {
        // Draw multiple circles to create cloud shape
        ctx.beginPath();
        ctx.arc(cloud.x - 10, cloud.y, cloud.size * 0.6, 0, Math.PI * 2);
        ctx.arc(cloud.x, cloud.y - 5, cloud.size, 0, Math.PI * 2);
        ctx.arc(cloud.x + 10, cloud.y, cloud.size * 0.7, 0, Math.PI * 2);
        ctx.arc(cloud.x + 20, cloud.y + 5, cloud.size * 0.5, 0, Math.PI * 2);
        ctx.fill();
    });
}

function startFlappyGame() {
    if (flappyGameState.gameActive) return;
    
    flappyGameState.bird = { x: 80, y: 300, velocity: 0, size: 20 };
    flappyGameState.pipes = [];
    flappyGameState.score = 0;
    flappyGameState.gameActive = true;
    flappyGameState.gameStarted = true;
    
    document.getElementById('flappy-instructions').style.display = 'none';
    document.getElementById('flappy-score').textContent = '0';
    
    // Generate first pipe after delay
    setTimeout(() => generatePipe(), 2000);
    
    // Start game loop
    if (flappyGameState.gameLoop) {
        clearInterval(flappyGameState.gameLoop);
    }
    flappyGameState.gameLoop = setInterval(updateFlappyGame, 1000/60);
}

function flap() {
    if (!flappyGameState.gameStarted) {
        startFlappyGame();
        return;
    }
    
    if (flappyGameState.gameActive) {
        flappyGameState.bird.velocity = JUMP_FORCE;
    } else {
        resetFlappyGame();
    }
}

function updateFlappyGame() {
    if (!flappyGameState.gameActive) return;
    
    // Update bird physics
    flappyGameState.bird.velocity += GRAVITY;
    flappyGameState.bird.y += flappyGameState.bird.velocity;
    
    // Update pipes
    flappyGameState.pipes.forEach(pipe => {
        pipe.x -= PIPE_SPEED;
    });
    
    // Remove off-screen pipes
    flappyGameState.pipes = flappyGameState.pipes.filter(pipe => pipe.x > -PIPE_WIDTH);
    
    // Generate new pipes
    if (flappyGameState.pipes.length === 0 || 
        flappyGameState.pipes[flappyGameState.pipes.length - 1].x < flappyGameState.canvas.width - 200) {
        generatePipe();
    }
    
    // Check collisions
    if (checkCollisions()) {
        gameOver();
        return;
    }
    
    // Check scoring
    flappyGameState.pipes.forEach(pipe => {
        if (!pipe.scored && pipe.x + PIPE_WIDTH < flappyGameState.bird.x) {
            flappyGameState.score++;
            pipe.scored = true;
            document.getElementById('flappy-score').textContent = flappyGameState.score;
        }
    });
    
    // Draw everything
    drawGame();
}

function generatePipe() {
    const minGapTop = 80;
    const maxGapTop = flappyGameState.canvas.height - PIPE_GAP - 100;
    const gapTop = Math.random() * (maxGapTop - minGapTop) + minGapTop;
    
    flappyGameState.pipes.push({
        x: flappyGameState.canvas.width,
        gapTop: gapTop,
        gapBottom: gapTop + PIPE_GAP,
        scored: false
    });
}

function checkCollisions() {
    const bird = flappyGameState.bird;
    const canvas = flappyGameState.canvas;
    
    // Ground and ceiling collision
    if (bird.y + bird.size > canvas.height - 50 || bird.y < 0) {
        return true;
    }
    
    // Pipe collision
    return flappyGameState.pipes.some(pipe => {
        if (bird.x + bird.size > pipe.x && bird.x < pipe.x + PIPE_WIDTH) {
            return bird.y < pipe.gapTop || bird.y + bird.size > pipe.gapBottom;
        }
        return false;
    });
}

function drawGame() {
    const ctx = flappyGameState.ctx;
    const canvas = flappyGameState.canvas;
    
    // Clear and draw background
    drawInitialState();
    
    // Draw pipes
    drawPipes(ctx);
    
    // Draw bird (will be drawn over background)
    drawBird(ctx);
}

function drawBird(ctx) {
    const bird = flappyGameState.bird;
    
    ctx.save();
    
    // Move to bird position
    ctx.translate(bird.x + bird.size/2, bird.y + bird.size/2);
    
    // Rotate based on velocity
    const rotation = Math.min(Math.max(bird.velocity * 0.1, -0.5), 0.5);
    ctx.rotate(rotation);
    
    // Draw bird body (circle)
    ctx.fillStyle = '#FFD700';
    ctx.strokeStyle = '#FFA500';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, bird.size/2, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    
    // Draw wing
    ctx.fillStyle = '#FF8C00';
    ctx.beginPath();
    ctx.ellipse(-bird.size/4, 0, bird.size/3, bird.size/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw eye
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(bird.size/4, -bird.size/6, bird.size/6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(bird.size/4, -bird.size/6, bird.size/12, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw beak
    ctx.fillStyle = '#FF6347';
    ctx.beginPath();
    ctx.moveTo(bird.size/2, 0);
    ctx.lineTo(bird.size/2 + bird.size/3, -bird.size/8);
    ctx.lineTo(bird.size/2 + bird.size/3, bird.size/8);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

function drawPipes(ctx) {
    flappyGameState.pipes.forEach(pipe => {
        // Pipe gradient
        const gradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + PIPE_WIDTH, 0);
        gradient.addColorStop(0, '#228B22');
        gradient.addColorStop(0.5, '#32CD32');
        gradient.addColorStop(1, '#228B22');
        
        ctx.fillStyle = gradient;
        ctx.strokeStyle = '#006400';
        ctx.lineWidth = 2;
        
        // Top pipe
        ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.gapTop);
        ctx.strokeRect(pipe.x, 0, PIPE_WIDTH, pipe.gapTop);
        
        // Bottom pipe
        ctx.fillRect(pipe.x, pipe.gapBottom, PIPE_WIDTH, flappyGameState.canvas.height - pipe.gapBottom);
        ctx.strokeRect(pipe.x, pipe.gapBottom, PIPE_WIDTH, flappyGameState.canvas.height - pipe.gapBottom);
        
        // Pipe caps
        ctx.fillStyle = '#006400';
        ctx.fillRect(pipe.x - 5, pipe.gapTop - 25, PIPE_WIDTH + 10, 25);
        ctx.fillRect(pipe.x - 5, pipe.gapBottom, PIPE_WIDTH + 10, 25);
    });
}

function gameOver() {
    flappyGameState.gameActive = false;
    if (flappyGameState.gameLoop) {
        clearInterval(flappyGameState.gameLoop);
        flappyGameState.gameLoop = null;
    }
    
    if (flappyGameState.score > flappyGameState.bestScore) {
        flappyGameState.bestScore = flappyGameState.score;
        localStorage.setItem('flappy-best', flappyGameState.bestScore);
        document.getElementById('flappy-best').textContent = flappyGameState.bestScore;
    }
    
    setTimeout(() => {
        const gameOverDiv = document.createElement('div');
        gameOverDiv.className = 'game-over-screen';
        gameOverDiv.innerHTML = `
            <h2>Game Over!</h2>
            <div class="final-score">Score: ${flappyGameState.score}</div>
            <div>Best: ${flappyGameState.bestScore}</div>
            <button class="play-again-btn" onclick="resetFlappyGame()">Play Again</button>
        `;
        
        const gameArea = document.querySelector('#flappybird-screen .game-area');
        if (gameArea) {
            gameArea.appendChild(gameOverDiv);
        }
    }, 500);
}

function resetFlappyGame() {
    const gameOverScreen = document.querySelector('.game-over-screen');
    if (gameOverScreen) gameOverScreen.remove();
    
    initFlappyBird();
}



// Asteroids Mini Game
let asteroidsGameState = {
    canvas: null,
    ctx: null,
    gameActive: false,
    gameLoop: null,
    keys: {},
    
    ship: {
        x: 300,
        y: 250,
        angle: 0,
        velocity: { x: 0, y: 0 },
        thrust: false,
        size: 15
    },
    
    bullets: [],
    asteroids: [],
    particles: [],
    
    score: 0,
    lives: 3,
    level: 1,
    asteroidsDestroyed: 0,
    shotsFired: 0,
    
    weaponHeat: 0,
    maxHeat: 100,
    overheat: false
};

function initAsteroids() {
    asteroidsGameState.canvas = document.getElementById('asteroids-canvas');
    asteroidsGameState.ctx = asteroidsGameState.canvas.getContext('2d');
    
    // Reset game state
    asteroidsGameState.gameActive = false;
    asteroidsGameState.score = 0;
    asteroidsGameState.lives = 3;
    asteroidsGameState.level = 1;
    asteroidsGameState.asteroidsDestroyed = 0;
    asteroidsGameState.shotsFired = 0;
    
    updateAsteroidsDisplay();
    
    // Add keyboard controls
    document.addEventListener('keydown', handleAsteroidsKeyDown);
    document.addEventListener('keyup', handleAsteroidsKeyUp);
    
    drawAsteroidsBackground();
}

function startAsteroidsGame() {
    asteroidsGameState.gameActive = true;
    document.getElementById('asteroids-instructions').style.display = 'none';
    
    // Reset ship position
    asteroidsGameState.ship = {
        x: asteroidsGameState.canvas.width / 2,
        y: asteroidsGameState.canvas.height / 2,
        angle: 0,
        velocity: { x: 0, y: 0 },
        thrust: false,
        size: 15
    };
    
    // Clear arrays
    asteroidsGameState.bullets = [];
    asteroidsGameState.asteroids = [];
    asteroidsGameState.particles = [];
    
    // Generate initial asteroids
    generateAsteroids();
    
    // Start game loop
    asteroidsGameState.gameLoop = setInterval(updateAsteroids, 1000/60); // 60 FPS
}

function generateAsteroids() {
    const numAsteroids = 3 + asteroidsGameState.level;
    
    for (let i = 0; i < numAsteroids; i++) {
        let x, y;
        
        // Spawn asteroids away from ship
        do {
            x = Math.random() * asteroidsGameState.canvas.width;
            y = Math.random() * asteroidsGameState.canvas.height;
        } while (
            Math.abs(x - asteroidsGameState.ship.x) < 100 && 
            Math.abs(y - asteroidsGameState.ship.y) < 100
        );
        
        asteroidsGameState.asteroids.push({
            x: x,
            y: y,
            velocity: {
                x: (Math.random() - 0.5) * 4,
                y: (Math.random() - 0.5) * 4
            },
            angle: Math.random() * Math.PI * 2,
            rotation: (Math.random() - 0.5) * 0.1,
            size: Math.random() < 0.3 ? 'large' : Math.random() < 0.6 ? 'medium' : 'small',
            vertices: Math.floor(Math.random() * 4) + 6
        });
    }
}

function handleAsteroidsKeyDown(e) {
    if (!asteroidsGameState.gameActive) return;
    
    asteroidsGameState.keys[e.code] = true;
    
    if (e.code === 'Space') {
        e.preventDefault();
        shoot();
    }
}

function handleAsteroidsKeyUp(e) {
    if (!asteroidsGameState.gameActive) return;
    asteroidsGameState.keys[e.code] = false;
}

function updateAsteroids() {
    if (!asteroidsGameState.gameActive) return;
    
    handleShipControls();
    updateShip();
    updateBullets();
    updateAsteroidsMovement();
    updateParticles();
    checkCollisions();
    updateWeaponHeat();
    
    // Check win condition
    if (asteroidsGameState.asteroids.length === 0) {
        nextLevel();
    }
    
    drawAsteroidsGame();
}

function handleShipControls() {
    const ship = asteroidsGameState.ship;
    
    // Rotation
    if (asteroidsGameState.keys['KeyA'] || asteroidsGameState.keys['ArrowLeft']) {
        ship.angle -= 0.1;
    }
    if (asteroidsGameState.keys['KeyD'] || asteroidsGameState.keys['ArrowRight']) {
        ship.angle += 0.1;
    }
    
    // Thrust
    ship.thrust = asteroidsGameState.keys['KeyW'] || 
                  asteroidsGameState.keys['ArrowUp'] || 
                  asteroidsGameState.keys['ShiftLeft'];
    
    if (ship.thrust) {
        const thrustPower = asteroidsGameState.keys['ShiftLeft'] ? 0.4 : 0.2;
        ship.velocity.x += Math.cos(ship.angle) * thrustPower;
        ship.velocity.y += Math.sin(ship.angle) * thrustPower;
        
        // Add thrust particles
        for (let i = 0; i < 3; i++) {
            asteroidsGameState.particles.push({
                x: ship.x - Math.cos(ship.angle) * 20,
                y: ship.y - Math.sin(ship.angle) * 20,
                velocity: {
                    x: -Math.cos(ship.angle) * 5 + (Math.random() - 0.5) * 2,
                    y: -Math.sin(ship.angle) * 5 + (Math.random() - 0.5) * 2
                },
                life: 20,
                color: `hsl(${Math.random() * 60 + 15}, 100%, 60%)`
            });
        }
        
        // Visual thrust effect
        asteroidsGameState.canvas.classList.add('thrust-active');
    } else {
        asteroidsGameState.canvas.classList.remove('thrust-active');
    }
}

function updateShip() {
    const ship = asteroidsGameState.ship;
    
    // Apply velocity
    ship.x += ship.velocity.x;
    ship.y += ship.velocity.y;
    
    // Friction
    ship.velocity.x *= 0.99;
    ship.velocity.y *= 0.99;
    
    // Screen wrapping
    if (ship.x < 0) ship.x = asteroidsGameState.canvas.width;
    if (ship.x > asteroidsGameState.canvas.width) ship.x = 0;
    if (ship.y < 0) ship.y = asteroidsGameState.canvas.height;
    if (ship.y > asteroidsGameState.canvas.height) ship.y = 0;
}

function shoot() {
    if (asteroidsGameState.overheat) return;
    
    const ship = asteroidsGameState.ship;
    
    asteroidsGameState.bullets.push({
        x: ship.x + Math.cos(ship.angle) * 20,
        y: ship.y + Math.sin(ship.angle) * 20,
        velocity: {
            x: Math.cos(ship.angle) * 8 + ship.velocity.x,
            y: Math.sin(ship.angle) * 8 + ship.velocity.y
        },
        life: 60,
        trail: []
    });
    
    asteroidsGameState.shotsFired++;
    asteroidsGameState.weaponHeat += 15;
    
    // Muzzle flash particles
    for (let i = 0; i < 5; i++) {
        asteroidsGameState.particles.push({
            x: ship.x + Math.cos(ship.angle) * 20,
            y: ship.y + Math.sin(ship.angle) * 20,
            velocity: {
                x: Math.cos(ship.angle) * 10 + (Math.random() - 0.5) * 4,
                y: Math.sin(ship.angle) * 10 + (Math.random() - 0.5) * 4
            },
            life: 10,
            color: `hsl(${Math.random() * 60 + 180}, 100%, 70%)`
        });
    }
}

function updateBullets() {
    for (let i = asteroidsGameState.bullets.length - 1; i >= 0; i--) {
        const bullet = asteroidsGameState.bullets[i];
        
        // Add to trail
        bullet.trail.push({ x: bullet.x, y: bullet.y });
        if (bullet.trail.length > 5) bullet.trail.shift();
        
        bullet.x += bullet.velocity.x;
        bullet.y += bullet.velocity.y;
        bullet.life--;
        
        // Screen wrapping
        if (bullet.x < 0) bullet.x = asteroidsGameState.canvas.width;
        if (bullet.x > asteroidsGameState.canvas.width) bullet.x = 0;
        if (bullet.y < 0) bullet.y = asteroidsGameState.canvas.height;
        if (bullet.y > asteroidsGameState.canvas.height) bullet.y = 0;
        
        // Remove dead bullets
        if (bullet.life <= 0) {
            asteroidsGameState.bullets.splice(i, 1);
        }
    }
}

function updateAsteroidsMovement() {
    asteroidsGameState.asteroids.forEach(asteroid => {
        asteroid.x += asteroid.velocity.x;
        asteroid.y += asteroid.velocity.y;
        asteroid.angle += asteroid.rotation;
        
        // Screen wrapping
        if (asteroid.x < 0) asteroid.x = asteroidsGameState.canvas.width;
        if (asteroid.x > asteroidsGameState.canvas.width) asteroid.x = 0;
        if (asteroid.y < 0) asteroid.y = asteroidsGameState.canvas.height;
        if (asteroid.y > asteroidsGameState.canvas.height) asteroid.y = 0;
    });
}

function updateParticles() {
    for (let i = asteroidsGameState.particles.length - 1; i >= 0; i--) {
        const particle = asteroidsGameState.particles[i];
        
        particle.x += particle.velocity.x;
        particle.y += particle.velocity.y;
        particle.velocity.x *= 0.95;
        particle.velocity.y *= 0.95;
        particle.life--;
        
        if (particle.life <= 0) {
            asteroidsGameState.particles.splice(i, 1);
        }
    }
}

function updateWeaponHeat() {
    if (asteroidsGameState.weaponHeat > 0) {
        asteroidsGameState.weaponHeat -= 2;
    }
    
    if (asteroidsGameState.weaponHeat >= asteroidsGameState.maxHeat) {
        asteroidsGameState.overheat = true;
    }
    
    if (asteroidsGameState.overheat && asteroidsGameState.weaponHeat <= 20) {
        asteroidsGameState.overheat = false;
    }
}

function checkCollisions() {
    // Bullet-asteroid collisions
    for (let i = asteroidsGameState.bullets.length - 1; i >= 0; i--) {
        const bullet = asteroidsGameState.bullets[i];
        
        for (let j = asteroidsGameState.asteroids.length - 1; j >= 0; j--) {
            const asteroid = asteroidsGameState.asteroids[j];
            const distance = Math.sqrt(
                Math.pow(bullet.x - asteroid.x, 2) + Math.pow(bullet.y - asteroid.y, 2)
            );
            
            const asteroidRadius = getAsteroidSize(asteroid.size);
            
            if (distance < asteroidRadius) {
                // Create explosion particles
                createExplosion(asteroid.x, asteroid.y, asteroidRadius);
                
                // Score points
                const points = asteroid.size === 'large' ? 20 : asteroid.size === 'medium' ? 50 : 100;
                asteroidsGameState.score += points;
                asteroidsGameState.asteroidsDestroyed++;
                
                // Split asteroid
                if (asteroid.size === 'large') {
                    splitAsteroid(asteroid, 'medium');
                } else if (asteroid.size === 'medium') {
                    splitAsteroid(asteroid, 'small');
                }
                
                // Remove bullet and asteroid
                asteroidsGameState.bullets.splice(i, 1);
                asteroidsGameState.asteroids.splice(j, 1);
                break;
            }
        }
    }
    
    // Ship-asteroid collisions
    const ship = asteroidsGameState.ship;
    asteroidsGameState.asteroids.forEach(asteroid => {
        const distance = Math.sqrt(
            Math.pow(ship.x - asteroid.x, 2) + Math.pow(ship.y - asteroid.y, 2)
        );
        
        if (distance < getAsteroidSize(asteroid.size) + ship.size) {
            loseLife();
        }
    });
}

function splitAsteroid(asteroid, newSize) {
    const numSplits = 2;
    
    for (let i = 0; i < numSplits; i++) {
        asteroidsGameState.asteroids.push({
            x: asteroid.x + (Math.random() - 0.5) * 20,
            y: asteroid.y + (Math.random() - 0.5) * 20,
            velocity: {
                x: (Math.random() - 0.5) * 6,
                y: (Math.random() - 0.5) * 6
            },
            angle: Math.random() * Math.PI * 2,
            rotation: (Math.random() - 0.5) * 0.15,
            size: newSize,
            vertices: Math.floor(Math.random() * 4) + 6
        });
    }
}

function createExplosion(x, y, size) {
    const numParticles = Math.floor(size / 3);
    
    for (let i = 0; i < numParticles; i++) {
        asteroidsGameState.particles.push({
            x: x,
            y: y,
            velocity: {
                x: (Math.random() - 0.5) * 8,
                y: (Math.random() - 0.5) * 8
            },
            life: 30 + Math.random() * 20,
            color: `hsl(${Math.random() * 60 + 15}, 100%, ${Math.random() * 30 + 50}%)`
        });
    }
}

function getAsteroidSize(size) {
    switch (size) {
        case 'large': return 40;
        case 'medium': return 25;
        case 'small': return 15;
        default: return 25;
    }
}

function loseLife() {
    asteroidsGameState.lives--;
    
    if (asteroidsGameState.lives <= 0) {
        gameOverAsteroids();
    } else {
        // Reset ship position with invincibility
        asteroidsGameState.ship.x = asteroidsGameState.canvas.width / 2;
        asteroidsGameState.ship.y = asteroidsGameState.canvas.height / 2;
        asteroidsGameState.ship.velocity = { x: 0, y: 0 };
    }
    
    updateAsteroidsDisplay();
}

function nextLevel() {
    asteroidsGameState.level++;
    
    // Show level complete message
    const levelMsg = document.createElement('div');
    levelMsg.className = 'level-complete';
    levelMsg.innerHTML = `
        <div>WAVE ${asteroidsGameState.level - 1} COMPLETE!</div>
        <div style="font-size: 1rem; margin-top: 1rem;">Get ready for Wave ${asteroidsGameState.level}...</div>
    `;
    
    document.querySelector('#asteroids-screen .game-area').appendChild(levelMsg);
    
    setTimeout(() => {
        levelMsg.remove();
        generateAsteroids();
    }, 2000);
    
    updateAsteroidsDisplay();
}

function gameOverAsteroids() {
    asteroidsGameState.gameActive = false;
    clearInterval(asteroidsGameState.gameLoop);
    
    const accuracy = asteroidsGameState.shotsFired > 0 ? 
        Math.round((asteroidsGameState.asteroidsDestroyed / asteroidsGameState.shotsFired) * 100) : 0;
    
    const gameOverDiv = document.createElement('div');
    gameOverDiv.className = 'game-over-asteroids';
    gameOverDiv.innerHTML = `
        <h2>SHIP DESTROYED!</h2>
        <div class="final-stats">
            <div>Final Score: ${asteroidsGameState.score}</div>
            <div>Wave Reached: ${asteroidsGameState.level}</div>
            <div>Asteroids Destroyed: ${asteroidsGameState.asteroidsDestroyed}</div>
            <div>Accuracy: ${accuracy}%</div>
        </div>
        <button class="play-again-asteroids" onclick="resetAsteroidsGame()">Launch Again</button>
    `;
    
    document.querySelector('#asteroids-screen .game-area').appendChild(gameOverDiv);
}

function resetAsteroidsGame() {
    const gameOverScreen = document.querySelector('.game-over-asteroids');
    if (gameOverScreen) gameOverScreen.remove();
    
    document.getElementById('asteroids-instructions').style.display = 'block';
    initAsteroids();
}

function drawAsteroidsGame() {
    const ctx = asteroidsGameState.ctx;
    
    drawAsteroidsBackground();
    drawParticles();
    drawAsteroids();
    drawBullets();
    drawShip();
    drawHUD();
}

function drawAsteroidsBackground() {
    const ctx = asteroidsGameState.ctx;
    
    // Space gradient
    const gradient = ctx.createRadialGradient(
        asteroidsGameState.canvas.width/2, asteroidsGameState.canvas.height/2, 0,
        asteroidsGameState.canvas.width/2, asteroidsGameState.canvas.height/2, 
        Math.max(asteroidsGameState.canvas.width, asteroidsGameState.canvas.height)
    );
    gradient.addColorStop(0, '#1a1a2e');
    gradient.addColorStop(0.5, '#16213e');
    gradient.addColorStop(1, '#0c0c0c');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, asteroidsGameState.canvas.width, asteroidsGameState.canvas.height);
    
    // Stars
    ctx.fillStyle = 'white';
    for (let i = 0; i < 100; i++) {
        const x = (i * 37) % asteroidsGameState.canvas.width;
        const y = (i * 47) % asteroidsGameState.canvas.height;
        const size = Math.sin(i) * 0.5 + 1;
        
        ctx.globalAlpha = 0.3 + (Math.sin(Date.now() * 0.001 + i) * 0.2);
        ctx.fillRect(x, y, size, size);
    }
    ctx.globalAlpha = 1;
}

function drawShip() {
    const ctx = asteroidsGameState.ctx;
    const ship = asteroidsGameState.ship;
    
    ctx.save();
    ctx.translate(ship.x, ship.y);
    ctx.rotate(ship.angle);
    
    // Ship body
    ctx.strokeStyle = '#4ecdc4';
    ctx.fillStyle = '#2ba8a0';
    ctx.lineWidth = 2;
    
    ctx.beginPath();
    ctx.moveTo(15, 0);
    ctx.lineTo(-10, -8);
    ctx.lineTo(-5, 0);
    ctx.lineTo(-10, 8);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Thrust effect
    if (ship.thrust) {
        ctx.strokeStyle = '#ff8e53';
        ctx.lineWidth = 3;
        const thrustLength = 15 + Math.random() * 10;
        
        ctx.beginPath();
        ctx.moveTo(-10, -3);
        ctx.lineTo(-10 - thrustLength, 0);
        ctx.lineTo(-10, 3);
        ctx.stroke();
    }
    
    ctx.restore();
}

function drawAsteroids() {
    const ctx = asteroidsGameState.ctx;
    
    asteroidsGameState.asteroids.forEach(asteroid => {
        ctx.save();
        ctx.translate(asteroid.x, asteroid.y);
        ctx.rotate(asteroid.angle);
        
        const radius = getAsteroidSize(asteroid.size);
        
        ctx.strokeStyle = '#8e44ad';
        ctx.fillStyle = '#6c3483';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        for (let i = 0; i < asteroid.vertices; i++) {
            const angle = (i / asteroid.vertices) * Math.PI * 2;
            const variation = 0.7 + Math.sin(i + asteroid.angle) * 0.3;
            const x = Math.cos(angle) * radius * variation;
            const y = Math.sin(angle) * radius * variation;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.restore();
    });
}

function drawBullets() {
    const ctx = asteroidsGameState.ctx;
    
    asteroidsGameState.bullets.forEach(bullet => {
        // Draw trail
        ctx.strokeStyle = 'rgba(78, 205, 196, 0.5)';
        ctx.lineWidth = 2;
        
        if (bullet.trail.length > 1) {
            ctx.beginPath();
            ctx.moveTo(bullet.trail[0].x, bullet.trail[0].y);
            for (let i = 1; i < bullet.trail.length; i++) {
                ctx.lineTo(bullet.trail[i].x, bullet.trail[i].y);
            }
            ctx.stroke();
        }
        
        // Draw bullet
        ctx.fillStyle = '#4ecdc4';
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
        ctx.fill();
    });
}

function drawParticles() {
    const ctx = asteroidsGameState.ctx;
    
    asteroidsGameState.particles.forEach(particle => {
        const alpha = particle.life / 50;
        ctx.fillStyle = particle.color || `rgba(255, 255, 255, ${alpha})`;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
        ctx.fill();
    });
}

function drawHUD() {
    const ctx = asteroidsGameState.ctx;
    
    // Weapon heat indicator
    const heatPercent = asteroidsGameState.weaponHeat / asteroidsGameState.maxHeat;
    const heatColor = asteroidsGameState.overheat ? '#ff6b6b' : heatPercent > 0.7 ? '#ffd93d' : '#4ecdc4';
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(10, 10, 120, 15);
    
    ctx.fillStyle = heatColor;
    ctx.fillRect(12, 12, (116 * heatPercent), 11);
    
    ctx.fillStyle = 'white';
    ctx.font = '12px Courier New';
    ctx.fillText('WEAPON HEAT', 10, 35);
    
    if (asteroidsGameState.overheat) {
        ctx.fillStyle = '#ff6b6b';
        ctx.font = 'bold 14px Courier New';
        ctx.fillText('OVERHEATED!', 10, 55);
    }
}

function updateAsteroidsDisplay() {
    document.getElementById('asteroids-score').textContent = asteroidsGameState.score;
    document.getElementById('asteroids-lives').textContent = asteroidsGameState.lives;
    document.getElementById('asteroids-level').textContent = asteroidsGameState.level;
    document.getElementById('asteroids-destroyed').textContent = asteroidsGameState.asteroidsDestroyed;
    
    const accuracy = asteroidsGameState.shotsFired > 0 ? 
        Math.round((asteroidsGameState.asteroidsDestroyed / asteroidsGameState.shotsFired) * 100) : 100;
    document.getElementById('asteroids-accuracy').textContent = accuracy + '%';
}

// Pixel Art Creator Game
let pixelArtState = {
    canvas: null,
    ctx: null,
    gridSize: 16,
    cellSize: 32,
    currentColor: '#000000',
    currentTool: 'brush',
    showGrid: true,
    isDrawing: false,
    artData: null,
    history: [],
    historyIndex: -1
};

const defaultColors = [
    '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00',
    '#FF00FF', '#00FFFF', '#808080', '#800000', '#008000', '#000080',
    '#808000', '#800080', '#008080', '#C0C0C0', '#FF8000', '#8000FF'
];

const pixelTemplates = {
    'smiley': {
        name: '😊 Smiley Face',
        size: 8,
        data: [
            '00000000',
            '01100110',
            '01100110',
            '00000000',
            '10000001',
            '01000010',
            '00111100',
            '00000000'
        ],
        colors: ['#FFFFFF', '#000000']
    },
    'heart': {
        name: '❤️ Heart',
        size: 8,
        data: [
            '01100110',
            '11111111',
            '11111111',
            '11111111',
            '01111110',
            '00111100',
            '00011000',
            '00000000'
        ],
        colors: ['#FFFFFF', '#FF0000']
    },
    'flower': {
        name: '🌸 Flower',
        size: 8,
        data: [
            '00011000',
            '01111110',
            '11100111',
            '11000011',
            '11100111',
            '01111110',
            '00011000',
            '00011000'
        ],
        colors: ['#FFFFFF', '#FF69B4']
    }
};

function initPixelArt() {
    pixelArtState.canvas = document.getElementById('pixel-canvas');
    pixelArtState.ctx = pixelArtState.canvas.getContext('2d');
    
    // Initialize grid
    changeGridSize(16);
    generateColorPalette();
    setupCanvasEvents();
    
    // Initialize art data
    pixelArtState.artData = Array(pixelArtState.gridSize).fill().map(() => 
        Array(pixelArtState.gridSize).fill('#FFFFFF')
    );
    
    saveToHistory();
    drawPixelGrid();
}

function generateColorPalette() {
    const palette = document.getElementById('color-palette');
    palette.innerHTML = '';
    
    defaultColors.forEach((color, index) => {
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = color;
        swatch.onclick = () => selectColor(color);
        
        if (index === 0) swatch.classList.add('active');
        
        palette.appendChild(swatch);
    });
}

function selectColor(color) {
    pixelArtState.currentColor = color;
    
    // Update active swatch
    document.querySelectorAll('.color-swatch').forEach(swatch => {
        swatch.classList.remove('active');
        if (swatch.style.backgroundColor === color || 
            swatch.style.backgroundColor === rgbToHex(swatch.style.backgroundColor)) {
            swatch.classList.add('active');
        }
    });
    
    document.getElementById('current-color-display').textContent = color;
    updateToolDisplay();
}

function selectTool(tool) {
    pixelArtState.currentTool = tool;
    
    // Update active tool button
    document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
    
    updateToolDisplay();
}

function updateToolDisplay() {
    document.getElementById('current-tool').textContent = 
        pixelArtState.currentTool.charAt(0).toUpperCase() + pixelArtState.currentTool.slice(1);
}

function changeGridSize(size) {
    pixelArtState.gridSize = size;
    pixelArtState.cellSize = 512 / size;
    
    // Update active grid button
    document.querySelectorAll('.grid-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    // Resize art data
    const newArtData = Array(size).fill().map(() => Array(size).fill('#FFFFFF'));
    
    if (pixelArtState.artData) {
        // Copy existing data
        for (let i = 0; i < Math.min(size, pixelArtState.artData.length); i++) {
            for (let j = 0; j < Math.min(size, pixelArtState.artData[0].length); j++) {
                newArtData[i][j] = pixelArtState.artData[i][j];
            }
        }
    }
    
    pixelArtState.artData = newArtData;
    document.getElementById('pixel-grid-size').textContent = `${size}x${size}`;
    
    saveToHistory();
    drawPixelGrid();
}

function setupCanvasEvents() {
    const canvas = pixelArtState.canvas;
    
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseleave', stopDrawing);
    canvas.addEventListener('mousemove', updateMousePosition);
    
    // Touch events for mobile
    canvas.addEventListener('touchstart', handleTouch);
    canvas.addEventListener('touchmove', handleTouch);
    canvas.addEventListener('touchend', stopDrawing);
}

function startDrawing(e) {
    pixelArtState.isDrawing = true;
    draw(e);
}

function draw(e) {
    if (!pixelArtState.isDrawing && pixelArtState.currentTool !== 'picker') return;
    
    const rect = pixelArtState.canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / pixelArtState.cellSize);
    const y = Math.floor((e.clientY - rect.top) / pixelArtState.cellSize);
    
    if (x >= 0 && x < pixelArtState.gridSize && y >= 0 && y < pixelArtState.gridSize) {
        switch (pixelArtState.currentTool) {
            case 'brush':
                pixelArtState.artData[y][x] = pixelArtState.currentColor;
                drawPixelGrid();
                break;
                
            case 'eraser':
                pixelArtState.artData[y][x] = '#FFFFFF';
                drawPixelGrid();
                break;
                
            case 'fill':
                if (pixelArtState.isDrawing) {
                    floodFill(x, y, pixelArtState.artData[y][x], pixelArtState.currentColor);
                    drawPixelGrid();
                }
                break;
                
            case 'picker':
                const pickedColor = pixelArtState.artData[y][x];
                selectColor(pickedColor);
                break;
        }
    }
}

function stopDrawing() {
    if (pixelArtState.isDrawing) {
        pixelArtState.isDrawing = false;
        saveToHistory();
    }
}

function updateMousePosition(e) {
    const rect = pixelArtState.canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / pixelArtState.cellSize);
    const y = Math.floor((e.clientY - rect.top) / pixelArtState.cellSize);
    
    document.getElementById('mouse-pos').textContent = `${x}, ${y}`;
}

function handleTouch(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' : 
                                     e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    
    pixelArtState.canvas.dispatchEvent(mouseEvent);
}

function floodFill(startX, startY, targetColor, fillColor) {
    if (targetColor === fillColor) return;
    
    const stack = [{x: startX, y: startY}];
    
    while (stack.length > 0) {
        const {x, y} = stack.pop();
        
        if (x < 0 || x >= pixelArtState.gridSize || y < 0 || y >= pixelArtState.gridSize) continue;
        if (pixelArtState.artData[y][x] !== targetColor) continue;
        
        pixelArtState.artData[y][x] = fillColor;
        
        stack.push({x: x + 1, y: y});
        stack.push({x: x - 1, y: y});
        stack.push({x: x, y: y + 1});
        stack.push({x: x, y: y - 1});
    }
}

function drawPixelGrid() {
    const ctx = pixelArtState.ctx;
    
    // Clear canvas
    ctx.clearRect(0, 0, pixelArtState.canvas.width, pixelArtState.canvas.height);
    
    // Draw pixels
    for (let y = 0; y < pixelArtState.gridSize; y++) {
        for (let x = 0; x < pixelArtState.gridSize; x++) {
            ctx.fillStyle = pixelArtState.artData[y][x];
            ctx.fillRect(
                x * pixelArtState.cellSize,
                y * pixelArtState.cellSize,
                pixelArtState.cellSize,
                pixelArtState.cellSize
            );
        }
    }
    
    // Draw grid lines
    if (pixelArtState.showGrid) {
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 1;
        
        for (let i = 0; i <= pixelArtState.gridSize; i++) {
            const pos = i * pixelArtState.cellSize;
            
            ctx.beginPath();
            ctx.moveTo(pos, 0);
            ctx.lineTo(pos, pixelArtState.canvas.height);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, pos);
            ctx.lineTo(pixelArtState.canvas.width, pos);
            ctx.stroke();
        }
    }
}

function clearCanvas() {
    if (confirm('Are you sure you want to clear the canvas?')) {
        pixelArtState.artData = Array(pixelArtState.gridSize).fill().map(() => 
            Array(pixelArtState.gridSize).fill('#FFFFFF')
        );
        saveToHistory();
        drawPixelGrid();
    }
}

function downloadArt() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = pixelArtState.gridSize * 10; // 10px per pixel for download
    canvas.height = pixelArtState.gridSize * 10;
    
    // Draw art without grid
    for (let y = 0; y < pixelArtState.gridSize; y++) {
        for (let x = 0; x < pixelArtState.gridSize; x++) {
            ctx.fillStyle = pixelArtState.artData[y][x];
            ctx.fillRect(x * 10, y * 10, 10, 10);
        }
    }
    
    // Download
    const link = document.createElement('a');
    link.download = `pixel-art-${Date.now()}.png`;
    link.href = canvas.toDataURL();
    link.click();
}

function loadTemplate() {
    const modal = document.createElement('div');
    modal.className = 'template-modal';
    
    let templateHTML = `
        <div class="template-content">
            <h3 style="color: #ffd93d; text-align: center; margin-bottom: 2rem;">Choose a Template</h3>
            <div class="template-grid">
    `;
    
    Object.entries(pixelTemplates).forEach(([key, template]) => {
        templateHTML += `
            <div class="template-item" onclick="applyTemplate('${key}')">
                <div style="font-size: 2rem; margin-bottom: 0.5rem;">${template.name.split(' ')[0]}</div>
                <div>${template.name.split(' ').slice(1).join(' ')}</div>
            </div>
        `;
    });
    
    templateHTML += `
            </div>
            <div style="text-align: center; margin-top: 2rem;">
                <button class="action-btn" onclick="closeTemplateModal()">✖️ Close</button>
            </div>
        </div>
    `;
    
    modal.innerHTML = templateHTML;
    document.body.appendChild(modal);
}

function applyTemplate(templateKey) {
    const template = pixelTemplates[templateKey];
    
    if (template.size !== pixelArtState.gridSize) {
        changeGridSize(template.size);
    }
    
    // Apply template data
    for (let y = 0; y < template.size; y++) {
        for (let x = 0; x < template.size; x++) {
            const colorIndex = parseInt(template.data[y][x]);
            pixelArtState.artData[y][x] = template.colors[colorIndex];
        }
    }
    
    saveToHistory();
    drawPixelGrid();
    closeTemplateModal();
}

function closeTemplateModal() {
    const modal = document.querySelector('.template-modal');
    if (modal) modal.remove();
}

function addCustomColor(color) {
    // Add to palette if not already there
    const palette = document.getElementById('color-palette');
    const existingSwatch = Array.from(palette.children).find(child => 
        child.style.backgroundColor === color || rgbToHex(child.style.backgroundColor) === color
    );
    
    if (!existingSwatch) {
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch';
        swatch.style.backgroundColor = color;
        swatch.onclick = () => selectColor(color);
        palette.appendChild(swatch);
    }
    
    selectColor(color);
}

function saveToHistory() {
    // Remove future history if we're not at the end
    pixelArtState.history = pixelArtState.history.slice(0, pixelArtState.historyIndex + 1);
    
    // Add current state
    pixelArtState.history.push(JSON.parse(JSON.stringify(pixelArtState.artData)));
    pixelArtState.historyIndex++;
    
    // Limit history size
    if (pixelArtState.history.length > 50) {
        pixelArtState.history.shift();
        pixelArtState.historyIndex--;
    }
}

function rgbToHex(rgb) {
    const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (!match) return rgb;
    
    const r = parseInt(match[1]);
    const g = parseInt(match[2]);
    const b = parseInt(match[3]);
    
    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
}

// Update the openGame function to include new games
function openGame(gameType) {
    currentGame = gameType;
    document.getElementById('home-screen').style.display = 'none';
    document.getElementById(gameType + '-screen').style.display = 'block';
    
    switch(gameType) {
        case 'snake': initSnake(); break;
        case 'memory': initMemory(); break;
        case 'simple': initSimple(); break;
        case 'quiz': initQuiz(); break;
        case 'typing': initTyping(); break;
        case 'reaction': initReaction(); break;
        case 'pong': initPong(); break;
        case 'mathblaster': initMathBlaster(); break;
        case 'aimtrainer': initAimTrainer(); break;
        case 'colormatch': initColorMatch(); break;
        case 'wordscramble': initWordScramble(); break;
        case 'game2048': initGame2048(); break;
        case 'flappybird': initFlappyBird(); break;
        case 'asteroids': initAsteroids(); break;
        case 'pixelart': initPixelArt(); break;
    }
}

// Add cleanup functions
gameStates['asteroids'] = {
    cleanup: () => {
        if (asteroidsGameState.gameLoop) {
            clearInterval(asteroidsGameState.gameLoop);
        }
        asteroidsGameState.gameActive = false;
        document.removeEventListener('keydown', handleAsteroidsKeyDown);
        document.removeEventListener('keyup', handleAsteroidsKeyUp);
    }
};

gameStates['pixelart'] = {
    cleanup: () => {
        // Pixel art doesn't need special cleanup, but we can clear templates modal
        const modal = document.querySelector('.template-modal');
        if (modal) modal.remove();
    }
};

// Hidden Object Game
// Hidden Object Game - CORRECTED VERSION

// Hidden Object Game - FIXED WITH PROPER VISUAL SCENE
let hiddenObjectState = {
    gameActive: false,
    timer: null,
    timeLeft: 180,
    score: 0,
    level: 1,
    objectsFound: 0,
    totalObjects: 8,
    clicksTotal: 0,
    correctClicks: 0,
    hintsLeft: 3,
    currentObjects: [],
    zoomLevel: 1
};

const hiddenObjectsData = {
    1: [
        {emoji: '🏠', name: 'House'}, {emoji: '🚗', name: 'Car'}, {emoji: '🌳', name: 'Tree'},
        {emoji: '⭐', name: 'Star'}, {emoji: '🌺', name: 'Flower'}, {emoji: '🦋', name: 'Butterfly'},
        {emoji: '🍎', name: 'Apple'}, {emoji: '📚', name: 'Book'}, {emoji: '🎈', name: 'Balloon'},
        {emoji: '⚽', name: 'Ball'}, {emoji: '🎸', name: 'Guitar'}, {emoji: '🎂', name: 'Cake'}
    ],
    2: [
        {emoji: '🛸', name: 'UFO'}, {emoji: '🚀', name: 'Rocket'}, {emoji: '👑', name: 'Crown'},
        {emoji: '💎', name: 'Diamond'}, {emoji: '🗝️', name: 'Key'}, {emoji: '📱', name: 'Phone'},
        {emoji: '🎭', name: 'Mask'}, {emoji: '🔍', name: 'Magnifier'}, {emoji: '🎯', name: 'Target'},
        {emoji: '🎪', name: 'Circus'}, {emoji: '🎨', name: 'Palette'}, {emoji: '🎵', name: 'Music'}
    ]
};

function initHiddenObject() {
    hiddenObjectState = {
        gameActive: false,
        timer: null,
        timeLeft: 180,
        score: 0,
        level: 1,
        objectsFound: 0,
        totalObjects: 8,
        clicksTotal: 0,
        correctClicks: 0,
        hintsLeft: 3,
        currentObjects: [],
        zoomLevel: 1
    };
    
    updateHiddenDisplay();
    generateRichScene();
    setupHiddenObjectEvents();
    
    document.getElementById('start-hidden-btn').style.display = 'block';
    document.getElementById('hint-btn').disabled = false;
    document.getElementById('hints-left').textContent = '3';
    resetZoom();
}

function generateRichScene() {
    const scene = document.getElementById('hidden-scene');
    scene.innerHTML = '';
    
    // Create a rich, detailed scene
    scene.style.background = `
        linear-gradient(to bottom, 
            #87CEEB 0%, 
            #98D8E8 30%, 
            #90EE90 70%, 
            #228B22 100%
        )
    `;
    
    // Add landscape elements
    addLandscapeElements(scene);
    addBuildings(scene);
    addNatureElements(scene);
    addSkyElements(scene);
}

function addLandscapeElements(scene) {
    // Mountains in background
    for (let i = 0; i < 3; i++) {
        const mountain = document.createElement('div');
        mountain.style.cssText = `
            position: absolute;
            bottom: 30%;
            left: ${i * 25 + 10}%;
            width: 0;
            height: 0;
            border-left: ${60 + i * 20}px solid transparent;
            border-right: ${60 + i * 20}px solid transparent;
            border-bottom: ${100 + i * 30}px solid #8B7355;
            z-index: 1;
            opacity: 0.7;
        `;
        scene.appendChild(mountain);
    }
    
    // Hills
    for (let i = 0; i < 4; i++) {
        const hill = document.createElement('div');
        hill.style.cssText = `
            position: absolute;
            bottom: 15%;
            left: ${i * 20 + 5}%;
            width: ${80 + Math.random() * 40}px;
            height: ${40 + Math.random() * 30}px;
            background: #9ACD32;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            z-index: 2;
            opacity: 0.8;
        `;
        scene.appendChild(hill);
    }
}

function addBuildings(scene) {
    // Houses and buildings
    const buildings = [
        {emoji: '🏠', left: 15, bottom: 25, size: '3rem'},
        {emoji: '🏢', left: 35, bottom: 20, size: '4rem'},
        {emoji: '🏪', left: 55, bottom: 28, size: '2.5rem'},
        {emoji: '🏫', left: 75, bottom: 22, size: '3.5rem'},
        {emoji: '⛪', left: 25, bottom: 35, size: '3rem'},
        {emoji: '🏰', left: 65, bottom: 15, size: '4rem'}
    ];
    
    buildings.forEach(building => {
        const buildingElement = document.createElement('div');
        buildingElement.textContent = building.emoji;
        buildingElement.style.cssText = `
            position: absolute;
            left: ${building.left}%;
            bottom: ${building.bottom}%;
            font-size: ${building.size};
            z-index: 3;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            pointer-events: none;
        `;
        scene.appendChild(buildingElement);
    });
}

function addNatureElements(scene) {
    // Trees and plants
    const trees = [
        {emoji: '🌳', count: 8},
        {emoji: '🌲', count: 6},
        {emoji: '🌴', count: 3},
        {emoji: '🌿', count: 10}
    ];
    
    trees.forEach(treeType => {
        for (let i = 0; i < treeType.count; i++) {
            const tree = document.createElement('div');
            tree.textContent = treeType.emoji;
            tree.style.cssText = `
                position: absolute;
                left: ${Math.random() * 90}%;
                top: ${Math.random() * 40 + 40}%;
                font-size: ${1.5 + Math.random() * 2}rem;
                z-index: ${Math.random() > 0.5 ? 2 : 4};
                opacity: ${0.6 + Math.random() * 0.4};
                transform: rotate(${Math.random() * 20 - 10}deg);
                pointer-events: none;
            `;
            scene.appendChild(tree);
        }
    });
    
    // Flowers and plants
    const plants = ['🌸', '🌺', '🌻', '🌷', '🌹', '💐', '🌼'];
    plants.forEach(plant => {
        for (let i = 0; i < 5; i++) {
            const plantElement = document.createElement('div');
            plantElement.textContent = plant;
            plantElement.style.cssText = `
                position: absolute;
                left: ${Math.random() * 95}%;
                top: ${Math.random() * 30 + 55}%;
                font-size: ${1 + Math.random()}rem;
                z-index: 3;
                opacity: ${0.7 + Math.random() * 0.3};
                pointer-events: none;
            `;
            scene.appendChild(plantElement);
        }
    });
}

function addSkyElements(scene) {
    // Clouds
    for (let i = 0; i < 6; i++) {
        const cloud = document.createElement('div');
        cloud.textContent = '☁️';
        cloud.style.cssText = `
            position: absolute;
            left: ${Math.random() * 85}%;
            top: ${Math.random() * 25}%;
            font-size: ${2 + Math.random() * 2}rem;
            z-index: 1;
            opacity: ${0.6 + Math.random() * 0.4};
            animation: cloudFloat ${10 + Math.random() * 10}s ease-in-out infinite alternate;
            pointer-events: none;
        `;
        scene.appendChild(cloud);
    }
    
    // Sun
    const sun = document.createElement('div');
    sun.textContent = '☀️';
    sun.style.cssText = `
        position: absolute;
        right: 10%;
        top: 10%;
        font-size: 3rem;
        z-index: 1;
        animation: sunGlow 3s ease-in-out infinite alternate;
        pointer-events: none;
    `;
    scene.appendChild(sun);
    
    // Birds in sky
    for (let i = 0; i < 3; i++) {
        const bird = document.createElement('div');
        bird.textContent = '🐦';
        bird.style.cssText = `
            position: absolute;
            left: ${Math.random() * 70}%;
            top: ${Math.random() * 20 + 15}%;
            font-size: 1.5rem;
            z-index: 2;
            animation: birdFly ${8 + Math.random() * 4}s linear infinite;
            pointer-events: none;
        `;
        scene.appendChild(bird);
    }
}

// Add animations CSS
const sceneAnimations = `
@keyframes cloudFloat {
    from { transform: translateX(0px); }
    to { transform: translateX(20px); }
}

@keyframes sunGlow {
    from { filter: drop-shadow(0 0 10px rgba(255, 255, 0, 0.5)); }
    to { filter: drop-shadow(0 0 20px rgba(255, 255, 0, 0.8)); }
}

@keyframes birdFly {
    from { transform: translateX(-20px); }
    to { transform: translateX(calc(100vw + 20px)); }
}
`;

// Add the animations to the document
if (!document.getElementById('scene-animations')) {
    const style = document.createElement('style');
    style.id = 'scene-animations';
    style.textContent = sceneAnimations;
    document.head.appendChild(style);
}

// Rest of the Hidden Object functions remain the same...
function setupHiddenObjectEvents() {
    const scene = document.getElementById('hidden-scene');
    scene.onclick = null;
    scene.removeEventListener('click', handleSceneClick);
    scene.addEventListener('click', handleSceneClick);
}

function handleSceneClick(e) {
    if (!hiddenObjectState.gameActive) return;
    
    hiddenObjectState.clicksTotal++;
    
    if (e.target.classList.contains('hidden-object')) {
        findObject(e.target);
    } else {
        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const missEffect = document.createElement('div');
        missEffect.className = 'click-effect';
        missEffect.style.left = (x - 30) + 'px';
        missEffect.style.top = (y - 30) + 'px';
        e.currentTarget.appendChild(missEffect);
        
        setTimeout(() => {
            if (missEffect.parentNode) {
                missEffect.remove();
            }
        }, 600);
    }
    
    updateHiddenDisplay();
}

function startHiddenGame() {
    if (hiddenObjectState.gameActive) return;
    
    hiddenObjectState.gameActive = true;
    hiddenObjectState.timeLeft = 180;
    hiddenObjectState.objectsFound = 0;
    hiddenObjectState.clicksTotal = 0;
    hiddenObjectState.correctClicks = 0;
    
    document.getElementById('start-hidden-btn').style.display = 'none';
    
    generateObjectsToFind();
    
    hiddenObjectState.timer = setInterval(() => {
        hiddenObjectState.timeLeft--;
        document.getElementById('hidden-time').textContent = hiddenObjectState.timeLeft;
        
        if (hiddenObjectState.timeLeft <= 0) {
            gameOverHidden();
        }
    }, 1000);
    
    updateHiddenDisplay();
}

function generateObjectsToFind() {
    const scene = document.getElementById('hidden-scene');
    const objectList = document.getElementById('object-list');
    
    // Clear previous objects
    document.querySelectorAll('.hidden-object').forEach(obj => obj.remove());
    objectList.innerHTML = '';
    
    const levelObjects = hiddenObjectsData[hiddenObjectState.level] || hiddenObjectsData[1];
    const shuffled = [...levelObjects].sort(() => Math.random() - 0.5);
    hiddenObjectState.currentObjects = shuffled.slice(0, hiddenObjectState.totalObjects);
    
    // Place objects in scene with better positioning
    hiddenObjectState.currentObjects.forEach((obj, index) => {
        const objElement = document.createElement('div');
        objElement.className = 'hidden-object';
        objElement.textContent = obj.emoji;
        objElement.dataset.name = obj.name;
        objElement.dataset.found = 'false';
        
        // Strategic positioning to avoid landscape elements
        let x, y;
        let attempts = 0;
        do {
            x = Math.random() * 80 + 10; // 10% to 90%
            y = Math.random() * 60 + 25; // 25% to 85%
            attempts++;
        } while (attempts < 20); // Limit attempts
        
        objElement.style.left = x + '%';
        objElement.style.top = y + '%';
        objElement.style.zIndex = '10';
        
        scene.appendChild(objElement);
        
        // Add to object list
        const listItem = document.createElement('div');
        listItem.className = 'object-item';
        listItem.innerHTML = `
            <div style="font-size: 1.5rem;">${obj.emoji}</div>
            <div class="object-name">${obj.name}</div>
        `;
        listItem.id = `list-${obj.name}`;
        objectList.appendChild(listItem);
    });
    
    updateProgressBar();
}

// Include all the other Hidden Object functions (findObject, useHint, etc.) from the previous version...
function findObject(objElement) {
    if (!hiddenObjectState.gameActive || objElement.dataset.found === 'true') return;
    
    objElement.dataset.found = 'true';
    objElement.classList.add('found');
    
    hiddenObjectState.objectsFound++;
    hiddenObjectState.correctClicks++;
    hiddenObjectState.score += 100 + (hiddenObjectState.timeLeft * 2);
    
    const listItem = document.getElementById(`list-${objElement.dataset.name}`);
    if (listItem) listItem.classList.add('found');
    
    createFoundEffect(objElement);
    updateHiddenDisplay();
    updateProgressBar();
    
    if (hiddenObjectState.objectsFound >= hiddenObjectState.totalObjects) {
        levelCompleteHidden();
    }
}

function createFoundEffect(objElement) {
    const rect = objElement.getBoundingClientRect();
    const sceneRect = objElement.parentElement.getBoundingClientRect();
    
    const x = rect.left - sceneRect.left + rect.width / 2;
    const y = rect.top - sceneRect.top + rect.height / 2;
    
    for (let i = 0; i < 8; i++) {
        const sparkle = document.createElement('div');
        sparkle.textContent = '✨';
        sparkle.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: ${y}px;
            font-size: 1rem;
            pointer-events: none;
            z-index: 30;
        `;
        
        const angle = (i / 8) * Math.PI * 2;
        const distance = 50;
        const targetX = x + Math.cos(angle) * distance;
        const targetY = y + Math.sin(angle) * distance;
        
        sparkle.animate([
            { transform: 'translate(0, 0) scale(1)', opacity: 1 },
            { transform: `translate(${targetX - x}px, ${targetY - y}px) scale(0)`, opacity: 0 }
        ], {
            duration: 800,
            delay: i * 50,
            easing: 'ease-out'
        });
        
        objElement.parentElement.appendChild(sparkle);
        
        setTimeout(() => {
            if (sparkle.parentNode) {
                sparkle.remove();
            }
        }, 1000 + (i * 50));
    }
}

function useHint() {
    if (hiddenObjectState.hintsLeft <= 0 || !hiddenObjectState.gameActive) return;
    
    hiddenObjectState.hintsLeft--;
    document.getElementById('hints-left').textContent = hiddenObjectState.hintsLeft;
    
    if (hiddenObjectState.hintsLeft <= 0) {
        document.getElementById('hint-btn').disabled = true;
    }
    
    const unfoundObjects = document.querySelectorAll('.hidden-object:not(.found)');
    if (unfoundObjects.length > 0) {
        const randomObj = unfoundObjects[Math.floor(Math.random() * unfoundObjects.length)];
        randomObj.classList.add('hint-glow');
        
        setTimeout(() => {
            randomObj.classList.remove('hint-glow');
        }, 3000);
    }
}

function zoomScene(factor) {
    hiddenObjectState.zoomLevel *= factor;
    hiddenObjectState.zoomLevel = Math.max(0.5, Math.min(2, hiddenObjectState.zoomLevel));
    
    const scene = document.getElementById('hidden-scene');
    scene.style.transform = `scale(${hiddenObjectState.zoomLevel})`;
}

function resetZoom() {
    hiddenObjectState.zoomLevel = 1;
    const scene = document.getElementById('hidden-scene');
    if (scene) {
        scene.style.transform = 'scale(1)';
    }
}

function updateHiddenDisplay() {
    document.getElementById('hidden-score').textContent = hiddenObjectState.score;
    document.getElementById('hidden-level').textContent = hiddenObjectState.level;
    document.getElementById('objects-found').textContent = hiddenObjectState.objectsFound;
    document.getElementById('found-count').textContent = hiddenObjectState.objectsFound;
    document.getElementById('total-count').textContent = hiddenObjectState.totalObjects;
    
    const accuracy = hiddenObjectState.clicksTotal > 0 ? 
        Math.round((hiddenObjectState.correctClicks / hiddenObjectState.clicksTotal) * 100) : 100;
    document.getElementById('accuracy-percent').textContent = accuracy + '%';
}

function updateProgressBar() {
    const progress = (hiddenObjectState.objectsFound / hiddenObjectState.totalObjects) * 100;
    const progressFill = document.getElementById('progress-fill');
    if (progressFill) {
        progressFill.style.width = progress + '%';
    }
}

function levelCompleteHidden() {
    hiddenObjectState.gameActive = false;
    if (hiddenObjectState.timer) {
        clearInterval(hiddenObjectState.timer);
        hiddenObjectState.timer = null;
    }
    
    const timeBonus = hiddenObjectState.timeLeft * 5;
    hiddenObjectState.score += timeBonus;
    hiddenObjectState.level++;
    
    const levelMsg = document.createElement('div');
    levelMsg.className = 'level-complete';
    levelMsg.innerHTML = `
        <h2>🎉 Level ${hiddenObjectState.level - 1} Complete!</h2>
        <div style="margin: 1rem 0;">All objects found!</div>
        <div style="margin: 1rem 0;">Time Bonus: ${timeBonus} points</div>
        <button class="start-game-btn" onclick="nextLevelHidden()">Continue to Level ${hiddenObjectState.level}</button>
    `;
    
    const gameArea = document.querySelector('#hiddenobject-screen .game-area');
    if (gameArea) {
        gameArea.appendChild(levelMsg);
    }
    
    updateHiddenDisplay();
}

function nextLevelHidden() {
    const levelComplete = document.querySelector('.level-complete');
    if (levelComplete) {
        levelComplete.remove();
    }
    
    hiddenObjectState.objectsFound = 0;
    hiddenObjectState.hintsLeft = 3;
    hiddenObjectState.timeLeft = Math.max(120, 180 - (hiddenObjectState.level * 20));
    
    document.getElementById('hints-left').textContent = '3';
    document.getElementById('hint-btn').disabled = false;
    
    generateRichScene();
    startHiddenGame();
}

function gameOverHidden() {
    hiddenObjectState.gameActive = false;
    if (hiddenObjectState.timer) {
        clearInterval(hiddenObjectState.timer);
        hiddenObjectState.timer = null;
    }
    
    const accuracy = hiddenObjectState.clicksTotal > 0 ? 
        Math.round((hiddenObjectState.correctClicks / hiddenObjectState.clicksTotal) * 100) : 0;
    
    alert(`Time's up!\nFinal Score: ${hiddenObjectState.score}\nLevel Reached: ${hiddenObjectState.level}\nObjects Found: ${hiddenObjectState.objectsFound}\nAccuracy: ${accuracy}%`);
    
    initHiddenObject();
}



// Tower Defense Game
let towerDefenseState = {
    canvas: null,
    ctx: null,
    gameActive: false,
    gameLoop: null,
    
    gold: 100,
    lives: 20,
    wave: 1,
    enemiesKilled: 0,
    towersBuilt: 0,
    
    selectedTowerType: null,
    selectedTower: null,
    buildMode: false,
    
    towers: [],
    enemies: [],
    projectiles: [],
    particles: [],
    
    path: [],
    waveInProgress: false,
    waveEnemies: [],
    enemiesSpawned: 0,
    enemiesRemaining: 0
};

const towerTypes = {
    basic: { cost: 25, damage: 20, range: 80, fireRate: 60, color: '#4ecdc4', projectileColor: '#4ecdc4' },
    cannon: { cost: 50, damage: 35, range: 70, fireRate: 90, color: '#ff6b6b', projectileColor: '#ff8e53', splash: 30 },
    ice: { cost: 40, damage: 15, range: 75, fireRate: 45, color: '#74b9ff', projectileColor: '#00cec9', slow: 0.5 },
    lightning: { cost: 80, damage: 40, range: 90, fireRate: 75, color: '#ffd93d', projectileColor: '#fdcb6e', chain: 3 }
};

const enemyTypes = {
    basic: { hp: 50, speed: 1, reward: 5, color: '#ff6b6b', size: 8 },
    fast: { hp: 30, speed: 2, reward: 8, color: '#74b9ff', size: 6 },
    tank: { hp: 120, speed: 0.5, reward: 15, color: '#a29bfe', size: 12 },
    flying: { hp: 40, speed: 1.5, reward: 10, color: '#fd79a8', size: 8, flying: true }
};

function initTowerDefense() {
    towerDefenseState.canvas = document.getElementById('td-canvas');
    towerDefenseState.ctx = towerDefenseState.canvas.getContext('2d');
    
    // Reset game state
    towerDefenseState.gold = 100;
    towerDefenseState.lives = 20;
    towerDefenseState.wave = 1;
    towerDefenseState.enemiesKilled = 0;
    towerDefenseState.towersBuilt = 0;
    towerDefenseState.selectedTowerType = null;
    towerDefenseState.buildMode = false;
    
    // Clear arrays
    towerDefenseState.towers = [];
    towerDefenseState.enemies = [];
    towerDefenseState.projectiles = [];
    towerDefenseState.particles = [];
    towerDefenseState.waveEnemies = [];
    
    generatePath();
    setupCanvasEvents();
    updateTowerDefenseDisplay();
    drawTowerDefenseGame();
}

function generatePath() {
    towerDefenseState.path = [
        { x: -20, y: 250 },
        { x: 100, y: 250 },
        { x: 100, y: 150 },
        { x: 200, y: 150 },
        { x: 200, y: 350 },
        { x: 350, y: 350 },
        { x: 350, y: 100 },
        { x: 500, y: 100 },
        { x: 500, y: 250 },
        { x: 620, y: 250 }
    ];
}

function setupCanvasEvents() {
    towerDefenseState.canvas.addEventListener('click', handleCanvasClick);
    towerDefenseState.canvas.addEventListener('mousemove', handleCanvasMouseMove);
}

function selectTower(type) {
    if (towerDefenseState.gold < towerTypes[type].cost) return;
    
    towerDefenseState.selectedTowerType = type;
    towerDefenseState.buildMode = true;
    towerDefenseState.selectedTower = null;
    
    // Update UI
    document.querySelectorAll('.tower-btn').forEach(btn => {
        btn.classList.remove('selected');
        const cost = towerTypes[btn.dataset.tower].cost;
        btn.classList.toggle('disabled', towerDefenseState.gold < cost);
    });
    
    document.querySelector(`[data-tower="${type}"]`).classList.add('selected');
    document.getElementById('selected-tower-info').style.display = 'none';
    
    towerDefenseState.canvas.classList.add('build-mode');
}

function handleCanvasClick(e) {
    const rect = towerDefenseState.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    if (towerDefenseState.buildMode && towerDefenseState.selectedTowerType) {
        if (canPlaceTower(x, y)) {
            placeTower(x, y, towerDefenseState.selectedTowerType);
        }
    } else {
        // Check if clicking on existing tower
        const clickedTower = towerDefenseState.towers.find(tower => {
            const distance = Math.sqrt(Math.pow(x - tower.x, 2) + Math.pow(y - tower.y, 2));
            return distance <= 20;
        });
        
        if (clickedTower) {
            selectExistingTower(clickedTower);
        } else {
            towerDefenseState.selectedTower = null;
            document.getElementById('selected-tower-info').style.display = 'none';
        }
    }
}

function handleCanvasMouseMove(e) {
    if (!towerDefenseState.buildMode) return;
    
    const rect = towerDefenseState.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Update canvas class based on valid placement
    const valid = canPlaceTower(x, y);
    towerDefenseState.canvas.classList.toggle('tower-placement-valid', valid);
    towerDefenseState.canvas.classList.toggle('tower-placement-invalid', !valid);
}

function canPlaceTower(x, y) {
    // Check distance from path
    for (let i = 0; i < towerDefenseState.path.length - 1; i++) {
        const pathPoint = towerDefenseState.path[i];
        const distance = Math.sqrt(Math.pow(x - pathPoint.x, 2) + Math.pow(y - pathPoint.y, 2));
        if (distance < 40) return false;
    }
    
    // Check distance from other towers
    for (const tower of towerDefenseState.towers) {
        const distance = Math.sqrt(Math.pow(x - tower.x, 2) + Math.pow(y - tower.y, 2));
        if (distance < 50) return false;
    }
    
    return true;
}

function placeTower(x, y, type) {
    const towerData = towerTypes[type];
    
    towerDefenseState.towers.push({
        x: x,
        y: y,
        type: type,
        level: 1,
        damage: towerData.damage,
        range: towerData.range,
        fireRate: towerData.fireRate,
        lastShot: 0,
        target: null,
        color: towerData.color
    });
    
    towerDefenseState.gold -= towerData.cost;
    towerDefenseState.towersBuilt++;
    towerDefenseState.buildMode = false;
    towerDefenseState.selectedTowerType = null;
    
    towerDefenseState.canvas.classList.remove('build-mode', 'tower-placement-valid', 'tower-placement-invalid');
    
    updateTowerDefenseDisplay();
    updateTowerButtons();
}

function selectExistingTower(tower) {
    towerDefenseState.selectedTower = tower;
    
    const infoDiv = document.getElementById('selected-tower-info');
    const detailsDiv = document.getElementById('tower-details');
    
    detailsDiv.innerHTML = `
        <div><strong>${tower.type.toUpperCase()} Tower</strong></div>
        <div>Level: ${tower.level}</div>
        <div>Damage: ${tower.damage}</div>
        <div>Range: ${tower.range}</div>
        <div>Upgrade Cost: ${tower.level * 30} gold</div>
        <div>Sell Value: ${Math.floor(towerTypes[tower.type].cost * 0.7)} gold</div>
    `;
    
    infoDiv.style.display = 'block';
}

function upgradeTower() {
    if (!towerDefenseState.selectedTower) return;
    
    const upgradeCost = towerDefenseState.selectedTower.level * 30;
    if (towerDefenseState.gold < upgradeCost) return;
    
    towerDefenseState.gold -= upgradeCost;
    towerDefenseState.selectedTower.level++;
    towerDefenseState.selectedTower.damage *= 1.3;
    towerDefenseState.selectedTower.range *= 1.1;
    
    selectExistingTower(towerDefenseState.selectedTower);
    updateTowerDefenseDisplay();
}

function sellTower() {
    if (!towerDefenseState.selectedTower) return;
    
    const sellValue = Math.floor(towerTypes[towerDefenseState.selectedTower.type].cost * 0.7);
    towerDefenseState.gold += sellValue;
    
    const index = towerDefenseState.towers.indexOf(towerDefenseState.selectedTower);
    towerDefenseState.towers.splice(index, 1);
    
    towerDefenseState.selectedTower = null;
    document.getElementById('selected-tower-info').style.display = 'none';
    updateTowerDefenseDisplay();
}

function startWave() {
    if (towerDefenseState.waveInProgress) return;
    
    towerDefenseState.waveInProgress = true;
    towerDefenseState.enemiesSpawned = 0;
    
    // Generate wave enemies
    const baseEnemies = 5 + towerDefenseState.wave * 2;
    towerDefenseState.waveEnemies = [];
    
    for (let i = 0; i < baseEnemies; i++) {
        let enemyType = 'basic';
        
        if (towerDefenseState.wave >= 3 && Math.random() < 0.3) enemyType = 'fast';
        if (towerDefenseState.wave >= 5 && Math.random() < 0.2) enemyType = 'tank';
        if (towerDefenseState.wave >= 7 && Math.random() < 0.15) enemyType = 'flying';
        
        towerDefenseState.waveEnemies.push(enemyType);
    }
    
    towerDefenseState.enemiesRemaining = towerDefenseState.waveEnemies.length;
    
    document.getElementById('wave-info').style.display = 'none';
    
    // Start game loop if not already running
    if (!towerDefenseState.gameLoop) {
        towerDefenseState.gameLoop = setInterval(updateTowerDefense, 1000/60);
    }
    
    updateTowerDefenseDisplay();
}

function updateTowerDefense() {
    spawnEnemies();
    updateEnemies();
    updateTowers();
    updateProjectiles();
    updateParticles();
    checkWaveComplete();
    
    drawTowerDefenseGame();
}

function spawnEnemies() {
    if (towerDefenseState.enemiesSpawned >= towerDefenseState.waveEnemies.length) return;
    
    // Spawn enemy every 30 frames (0.5 seconds)
    if (Date.now() % 500 < 20) {
        const enemyType = towerDefenseState.waveEnemies[towerDefenseState.enemiesSpawned];
        const enemyData = enemyTypes[enemyType];
        
        towerDefenseState.enemies.push({
            type: enemyType,
            hp: enemyData.hp * (1 + towerDefenseState.wave * 0.2),
            maxHp: enemyData.hp * (1 + towerDefenseState.wave * 0.2),
            speed: enemyData.speed,
            reward: enemyData.reward,
            x: towerDefenseState.path[0].x,
            y: towerDefenseState.path[0].y,
            pathIndex: 0,
            pathProgress: 0,
            color: enemyData.color,
            size: enemyData.size,
            flying: enemyData.flying || false,
            slowEffect: 1,
            slowDuration: 0
        });
        
        towerDefenseState.enemiesSpawned++;
    }
}

function updateEnemies() {
    for (let i = towerDefenseState.enemies.length - 1; i >= 0; i--) {
        const enemy = towerDefenseState.enemies[i];
        
        // Update slow effect
        if (enemy.slowDuration > 0) {
            enemy.slowDuration--;
        } else {
            enemy.slowEffect = 1;
        }
        
        // Move along path
        const currentSpeed = enemy.speed * enemy.slowEffect;
        const currentPath = towerDefenseState.path[enemy.pathIndex];
        const nextPath = towerDefenseState.path[enemy.pathIndex + 1];
        
        if (nextPath) {
            const dx = nextPath.x - currentPath.x;
            const dy = nextPath.y - currentPath.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            enemy.pathProgress += currentSpeed / distance;
            
            if (enemy.pathProgress >= 1) {
                enemy.pathIndex++;
                enemy.pathProgress = 0;
                
                if (enemy.pathIndex >= towerDefenseState.path.length - 1) {
                    // Enemy reached end
                    towerDefenseState.lives--;
                    towerDefenseState.enemies.splice(i, 1);
                    towerDefenseState.enemiesRemaining--;
                    
                    if (towerDefenseState.lives <= 0) {
                        gameOverTowerDefense();
                    }
                    continue;
                }
            }
            
            // Update position
            enemy.x = currentPath.x + (nextPath.x - currentPath.x) * enemy.pathProgress;
            enemy.y = currentPath.y + (nextPath.y - currentPath.y) * enemy.pathProgress;
        }
        
        // Remove dead enemies
        if (enemy.hp <= 0) {
            towerDefenseState.gold += enemy.reward;
            towerDefenseState.enemiesKilled++;
            towerDefenseState.enemies.splice(i, 1);
            towerDefenseState.enemiesRemaining--;
            
            // Create death particles
            createDeathParticles(enemy.x, enemy.y);
        }
    }
}

function updateTowers() {
    towerDefenseState.towers.forEach(tower => {
        tower.lastShot++;
        
        if (tower.lastShot >= tower.fireRate) {
            // Find target
            let target = null;
            let closestDistance = tower.range;
            
            towerDefenseState.enemies.forEach(enemy => {
                if (tower.type !== 'lightning' && enemy.flying && tower.type !== 'basic') return;
                
                const distance = Math.sqrt(Math.pow(tower.x - enemy.x, 2) + Math.pow(tower.y - enemy.y, 2));
                
                if (distance <= tower.range && distance < closestDistance) {
                    target = enemy;
                    closestDistance = distance;
                }
            });
            
            if (target) {
                shootProjectile(tower, target);
                tower.lastShot = 0;
            }
        }
    });
}

function shootProjectile(tower, target) {
    const projectile = {
        x: tower.x,
        y: tower.y,
        targetX: target.x,
        targetY: target.y,
        target: target,
        tower: tower,
        speed: 8,
        color: towerTypes[tower.type].projectileColor
    };
    
    // Calculate direction
    const dx = target.x - tower.x;
    const dy = target.y - tower.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    projectile.velX = (dx / distance) * projectile.speed;
    projectile.velY = (dy / distance) * projectile.speed;
    
    towerDefenseState.projectiles.push(projectile);
}

function updateProjectiles() {
    for (let i = towerDefenseState.projectiles.length - 1; i >= 0; i--) {
        const projectile = towerDefenseState.projectiles[i];
        
        projectile.x += projectile.velX;
        projectile.y += projectile.velY;
        
        // Check collision with target
        if (projectile.target && projectile.target.hp > 0) {
            const distance = Math.sqrt(
                Math.pow(projectile.x - projectile.target.x, 2) + 
                Math.pow(projectile.y - projectile.target.y, 2)
            );
            
            if (distance < 15) {
                hitTarget(projectile);
                towerDefenseState.projectiles.splice(i, 1);
                continue;
            }
        }
        
        // Remove projectiles that are off-screen
        if (projectile.x < 0 || projectile.x > 600 || projectile.y < 0 || projectile.y > 500) {
            towerDefenseState.projectiles.splice(i, 1);
        }
    }
}

function hitTarget(projectile) {
    const tower = projectile.tower;
    const target = projectile.target;
    
    if (!target || target.hp <= 0) return;
    
    // Apply damage
    target.hp -= tower.damage;
    
    // Special effects
    switch (tower.type) {
        case 'cannon':
            // Splash damage
            towerDefenseState.enemies.forEach(enemy => {
                if (enemy === target) return;
                const distance = Math.sqrt(
                    Math.pow(enemy.x - target.x, 2) + Math.pow(enemy.y - target.y, 2)
                );
                if (distance <= 30) {
                    enemy.hp -= tower.damage * 0.5;
                }
            });
            break;
            
        case 'ice':
            // Slow effect
            target.slowEffect = 0.5;
            target.slowDuration = 120; // 2 seconds at 60fps
            break;
            
        case 'lightning':
            // Chain lightning
            let chainTargets = [target];
            for (let i = 0; i < 2; i++) {
                let nextTarget = null;
                let closestDistance = 60;
                
                towerDefenseState.enemies.forEach(enemy => {
                    if (chainTargets.includes(enemy)) return;
                    
                    const lastTarget = chainTargets[chainTargets.length - 1];
                    const distance = Math.sqrt(
                        Math.pow(enemy.x - lastTarget.x, 2) + Math.pow(enemy.y - lastTarget.y, 2)
                    );
                    
                    if (distance < closestDistance) {
                        nextTarget = enemy;
                        closestDistance = distance;
                    }
                });
                
                if (nextTarget) {
                    nextTarget.hp -= tower.damage * 0.7;
                    chainTargets.push(nextTarget);
                }
            }
            break;
    }
    
    // Create hit particles
    createHitParticles(target.x, target.y);
    
    // Show damage number
    showDamageNumber(target.x, target.y, tower.damage);
}

function createHitParticles(x, y) {
    for (let i = 0; i < 5; i++) {
        towerDefenseState.particles.push({
            x: x,
            y: y,
            velX: (Math.random() - 0.5) * 4,
            velY: (Math.random() - 0.5) * 4,
            life: 30,
            color: '#ff8e53'
        });
    }
}

function createDeathParticles(x, y) {
    for (let i = 0; i < 10; i++) {
        towerDefenseState.particles.push({
            x: x,
            y: y,
            velX: (Math.random() - 0.5) * 6,
            velY: (Math.random() - 0.5) * 6,
            life: 40,
            color: '#ffd93d'
        });
    }
}

function showDamageNumber(x, y, damage) {
    const damageElement = document.createElement('div');
    damageElement.className = 'damage-number';
    damageElement.textContent = damage;
    damageElement.style.left = x + 'px';
    damageElement.style.top = y + 'px';
    
    const canvasRect = towerDefenseState.canvas.getBoundingClientRect();
    damageElement.style.position = 'absolute';
    damageElement.style.left = (canvasRect.left + x) + 'px';
    damageElement.style.top = (canvasRect.top + y) + 'px';
    
    document.body.appendChild(damageElement);
    
    setTimeout(() => damageElement.remove(), 1000);
}

function updateParticles() {
    for (let i = towerDefenseState.particles.length - 1; i >= 0; i--) {
        const particle = towerDefenseState.particles[i];
        
        particle.x += particle.velX;
        particle.y += particle.velY;
        particle.velX *= 0.95;
        particle.velY *= 0.95;
        particle.life--;
        
        if (particle.life <= 0) {
            towerDefenseState.particles.splice(i, 1);
        }
    }
}

function checkWaveComplete() {
    if (towerDefenseState.waveInProgress && 
        towerDefenseState.enemiesSpawned >= towerDefenseState.waveEnemies.length &&
        towerDefenseState.enemies.length === 0) {
        
        // Wave completed
        towerDefenseState.waveInProgress = false;
        towerDefenseState.wave++;
        towerDefenseState.gold += 50; // Wave completion bonus
        
        clearInterval(towerDefenseState.gameLoop);
        towerDefenseState.gameLoop = null;
        
        document.getElementById('wave-info').style.display = 'block';
        document.querySelector('.wave-status').textContent = `Prepare for Wave ${towerDefenseState.wave}!`;
        
        updateTowerDefenseDisplay();
    }
}

function gameOverTowerDefense() {
    clearInterval(towerDefenseState.gameLoop);
    towerDefenseState.gameLoop = null;
    
    const gameOverDiv = document.createElement('div');
    gameOverDiv.className = 'game-over-td';
    gameOverDiv.innerHTML = `
        <h2>GAME OVER!</h2>
        <div style="margin: 1rem 0;">Wave Reached: ${towerDefenseState.wave}</div>
        <div style="margin: 1rem 0;">Enemies Killed: ${towerDefenseState.enemiesKilled}</div>
        <div style="margin: 1rem 0;">Towers Built: ${towerDefenseState.towersBuilt}</div>
        <button class="play-again-asteroids" onclick="resetTowerDefense()">Play Again</button>
    `;
    
    document.querySelector('#towerdefense-screen .game-area').appendChild(gameOverDiv);
}

function resetTowerDefense() {
    const gameOverScreen = document.querySelector('.game-over-td');
    if (gameOverScreen) gameOverScreen.remove();
    
    document.getElementById('wave-info').style.display = 'block';
    document.querySelector('.wave-status').textContent = 'Prepare for Wave 1!';
    
    initTowerDefense();
}

function drawTowerDefenseGame() {
    const ctx = towerDefenseState.ctx;
    
    // Clear canvas
    ctx.clearRect(0, 0, 600, 500);
    
    // Draw background
    const gradient = ctx.createLinearGradient(0, 0, 600, 500);
    gradient.addColorStop(0, '#2d5a27');
    gradient.addColorStop(1, '#4a7c59');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 600, 500);
    
    // Draw path
    ctx.strokeStyle = '#8B4513';
    ctx.lineWidth = 30;
    ctx.beginPath();
    ctx.moveTo(towerDefenseState.path[0].x, towerDefenseState.path[0].y);
    towerDefenseState.path.forEach(point => ctx.lineTo(point.x, point.y));
    ctx.stroke();
    
    // Draw path border
    ctx.strokeStyle = '#654321';
    ctx.lineWidth = 34;
    ctx.beginPath();
    ctx.moveTo(towerDefenseState.path[0].x, towerDefenseState.path[0].y);
    towerDefenseState.path.forEach(point => ctx.lineTo(point.x, point.y));
    ctx.stroke();
    
    // Draw towers
    towerDefenseState.towers.forEach(tower => {
        // Tower base
        ctx.fillStyle = tower.color;
        ctx.beginPath();
        ctx.arc(tower.x, tower.y, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Tower outline
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Tower level indicator
        ctx.fillStyle = 'white';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(tower.level, tower.x, tower.y + 4);
        
        // Range indicator for selected tower
        if (tower === towerDefenseState.selectedTower) {
            ctx.strokeStyle = 'rgba(78, 205, 196, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(tower.x, tower.y, tower.range, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    });
    
    // Draw enemies
    towerDefenseState.enemies.forEach(enemy => {
        ctx.fillStyle = enemy.color;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Health bar
        const barWidth = enemy.size * 2;
        const barHeight = 4;
        const healthPercent = enemy.hp / enemy.maxHp;
        
        ctx.fillStyle = '#333';
        ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 8, barWidth, barHeight);
        
        ctx.fillStyle = healthPercent > 0.5 ? '#4caf50' : healthPercent > 0.25 ? '#ffd93d' : '#ff6b6b';
        ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.size - 8, barWidth * healthPercent, barHeight);
        
        // Slow effect indicator
        if (enemy.slowEffect < 1) {
            ctx.strokeStyle = '#74b9ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(enemy.x, enemy.y, enemy.size + 3, 0, Math.PI * 2);
            ctx.stroke();
        }
    });
    
    // Draw projectiles
    towerDefenseState.projectiles.forEach(projectile => {
        ctx.fillStyle = projectile.color;
        ctx.beginPath();
        ctx.arc(projectile.x, projectile.y, 3, 0, Math.PI * 2);
        ctx.fill();
    });
    
    // Draw particles
    towerDefenseState.particles.forEach(particle => {
        const alpha = particle.life / 40;
        ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
        ctx.fill();
    });
    
    // Draw build preview
    if (towerDefenseState.buildMode && towerDefenseState.selectedTowerType) {
        // This will be handled by mouse move events
    }
}

function updateTowerDefenseDisplay() {
    document.getElementById('td-gold').textContent = towerDefenseState.gold;
    document.getElementById('td-lives').textContent = towerDefenseState.lives;
    document.getElementById('td-wave').textContent = towerDefenseState.wave;
    document.getElementById('enemies-killed').textContent = towerDefenseState.enemiesKilled;
    document.getElementById('towers-built').textContent = towerDefenseState.towersBuilt;
    document.getElementById('enemies-remaining').textContent = towerDefenseState.enemiesRemaining;
    
    const progress = towerDefenseState.waveEnemies.length > 0 ? 
        ((towerDefenseState.waveEnemies.length - towerDefenseState.enemiesRemaining) / towerDefenseState.waveEnemies.length) * 100 : 0;
    document.getElementById('wave-progress-fill').style.width = progress + '%';
    
    updateTowerButtons();
}

function updateTowerButtons() {
    document.querySelectorAll('.tower-btn').forEach(btn => {
        const towerType = btn.dataset.tower;
        const cost = towerTypes[towerType].cost;
        btn.classList.toggle('disabled', towerDefenseState.gold < cost);
    });
}

// Update the openGame function to include new games
function openGame(gameType) {
    currentGame = gameType;
    document.getElementById('home-screen').style.display = 'none';
    document.getElementById(gameType + '-screen').style.display = 'block';
    
    switch(gameType) {
        case 'snake': initSnake(); break;
        case 'memory': initMemory(); break;
        case 'simple': initSimple(); break;
        case 'quiz': initQuiz(); break;
        case 'typing': initTyping(); break;
        case 'reaction': initReaction(); break;
        case 'pong': initPong(); break;
        case 'mathblaster': initMathBlaster(); break;
        case 'aimtrainer': initAimTrainer(); break;
        case 'colormatch': initColorMatch(); break;
        case 'wordscramble': initWordScramble(); break;
        case 'game2048': initGame2048(); break;
        case 'flappybird': initFlappyBird(); break;
        case 'asteroids': initAsteroids(); break;
        case 'pixelart': initPixelArt(); break;
        case 'hiddenobject': initHiddenObject(); break;
        case 'towerdefense': initTowerDefense(); break;
    }
}

// Add cleanup functions
gameStates['hiddenobject'] = {
    cleanup: () => {
        if (hiddenObjectState.timer) {
            clearInterval(hiddenObjectState.timer);
        }
        hiddenObjectState.gameActive = false;
    }
};

gameStates['towerdefense'] = {
    cleanup: () => {
        if (towerDefenseState.gameLoop) {
            clearInterval(towerDefenseState.gameLoop);
        }
        towerDefenseState.gameActive = false;
    }
};




    </script>
</body>
</html>

